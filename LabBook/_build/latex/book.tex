%% Generated by Sphinx.
\def\sphinxdocclass{jupyterBook}
\documentclass[letterpaper,10pt,english]{jupyterBook}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}



        % Start of preamble defined in sphinx-jupyterbook-latex %
         \usepackage[Latin,Greek]{ucharclasses}
        \usepackage{unicode-math}
        % fixing title of the toc
        \addto\captionsenglish{\renewcommand{\contentsname}{Contents}}
        \hypersetup{
            pdfencoding=auto,
            psdextra
        }
        % End of preamble defined in sphinx-jupyterbook-latex %
        

\title{Kalman Filters and IMU}
\date{Jul 11, 2025}
\release{}
\author{Malachi Hibbins}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{0Intro::doc}}


\sphinxAtStartPar
This report looks at Kalman filters and how they can be used with the aim to improve undergraduate experiments. Kalman filters are a optimal estimation algorithm used to predict the true state (a description of the system) from a set of noisy measurements. The Kalman filter uses the current state along with a model, that reflects the physics of the system, to predict the next state. This is then compared with measurements to improve on this prediction. The model in the Kalman filter is dependent on how the system behaves, whereas most filters use the same algorithm with a couple of parameters that are tuned. Often the Kalman filter will use measurements from multiple types of sensors to improve accuracy, sensor fusion.

\sphinxAtStartPar
Experiment I uses a 6 axis IMU to track position and attitude. The IMU measures acceleration, in the x, y and z directions and angular velocity in the yaw, pitch and roll directions. The position and attitude estimates are inaccurate due to drift associated with integration. Using Kalman filters to fuse sensor data between the accelerometer and gyroscope as well as non inertial sensors like magnetometer and GPS would greatly improve the results of this experiment.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\Large Contents}
\end{DUlineblock}
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{1FilterBasics::doc}]{\sphinxcrossref{1 Basics Of Filtering}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{2KalmanFilters::doc}]{\sphinxcrossref{2 Kalman filters}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{3ExampleBatteryOutput::doc}]{\sphinxcrossref{3 Example: Battery output}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{4ExampleVelocityFromPosition::doc}]{\sphinxcrossref{4 Example: Velocity from position}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{5IMU::doc}]{\sphinxcrossref{5 Example: Attitude using a gyroscope and accelerometer}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{6ExtendedKalman::doc}]{\sphinxcrossref{6 Example : Position using GPS and accelerometer data}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{7RealData::doc}]{\sphinxcrossref{7 Experiment: Attitude Using a 6/9 axis IMU}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{8TestingFilters::doc}]{\sphinxcrossref{8 Experiment: Quantitative Comparison of Kalman Filter Performance}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{99Bibliography::doc}]{\sphinxcrossref{Bibliography}}}

\end{itemize}

\sphinxstepscope


\chapter{1 Basics Of Filtering}
\label{\detokenize{1FilterBasics:basics-of-filtering}}\label{\detokenize{1FilterBasics::doc}}
\sphinxAtStartPar
Before looking at how Kalman filters worked basic recursive filters were tested. Later the performance between these and the Kalman filter will be compared. The purpose of a filter is to consider measurments and use these to form an estimate of the true state \(x_k\) which is a column vector describing the system, in these example the state is 1D. Measurements of the true state, \(z_k\) are corrupted by noise. The filters output an estimate of the true state \(\hat{x}_k\).


\section{1.1 Average filters}
\label{\detokenize{1FilterBasics:average-filters}}
\sphinxAtStartPar
For a signal where \(x_k\) is constant, e.g. calculating the output from a battery, computing the mean is a reasonable way to determine \(\hat{x}_k\). The average is computed as:
\begin{equation}\label{equation:1FilterBasics:eq-average}
\begin{split}\hat{x}_k = \frac{z_1+z_2+z_3+...+z_k}{k}\end{split}
\end{equation}
\sphinxAtStartPar
In this case \(\hat{x}_k\) is the average. However \(\hat{x}_k\) needs to be computed at every time\sphinxhyphen{}step, \eqref{equation:1FilterBasics:eq-average} isn’t going to be very efficient to compute. Written in a more computationally efficient form:
\begin{equation}\label{equation:1FilterBasics:eq-recursive}
\begin{split}\hat{x}_k = \left(\frac{k-1}{k}\right)\hat{x}_{k-1} + \frac{z_k}{k}\end{split}
\end{equation}
\sphinxAtStartPar
Let \(\alpha = \frac{k-1}{k}\), \eqref{equation:1FilterBasics:eq-recursive} can be rewritten as:
\begin{equation}\label{equation:1FilterBasics:eq-alpha}
\begin{split}\hat{x}_k = \alpha \hat{x}_{k-1} + (1 - \alpha) z_k\end{split}
\end{equation}
\sphinxAtStartPar
This will be referred to as the recursive average filter.
The code for this filter can be found in \sphinxhref{https://github.com/MalachiHibbins/IMU/tree/main/1AverageFilter}{github}. The programme is made up from 3 files: \sphinxcode{\sphinxupquote{GetVolt.py}}, \sphinxcode{\sphinxupquote{RcsAvgFilter.py}} and \sphinxcode{\sphinxupquote{Test.py}}. The first file generates a noisy signal, the second contains the filter and the third runs the filter on the generated signal.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-8}.png}
\caption{A noisy signal with mean 25 and standard deviation 0.5, fitted with a moving average filter.}\label{\detokenize{1FilterBasics:fig-noisy-signal}}\end{figure}

\sphinxAtStartPar
The filter is efficient and converges to the correct value very quickly. Due to random variation the filter fluctuates around the correct value. The average filter is very good when \(\hat{x}_k\) is constant, however it won’t converge to a changing signal.


\section{1.2 Moving Average filters}
\label{\detokenize{1FilterBasics:moving-average-filters}}
\sphinxAtStartPar
The moving average is used to remove noise over a constantly varying signal. Here \(\hat{x}_k\) represents the moving average at time \(t_k\) and \(n\) represents the window size which is a parameter to be tuned. The moving average can be written as:
\begin{equation}\label{equation:1FilterBasics:eq-moving-average}
\begin{split}\hat{x}_k = \frac{z_{k-n+1} + z_{k-n+2}+...+z_k}{n}\end{split}
\end{equation}
\sphinxAtStartPar
\(\hat{x}_k\) can be written recursively using the previous estimate \(\hat{x}_{k-1}\) and the new measurement \(z_k\):
\begin{equation}\label{equation:1FilterBasics:eq-moving-average-rec}
\begin{split}\hat{x}_k = \hat{x}_{k-1} + \frac{z_n - z_{k-n}}{n} \end{split}
\end{equation}
\sphinxAtStartPar
for more efficient computation. The code for the following graphs can be found in \sphinxhref{https://github.com/MalachiHibbins/IMU/tree/main/2MovingAverageFilter}{github}. The programme is made up from 3 files: \sphinxcode{\sphinxupquote{GenTestSig.py}}, \sphinxcode{\sphinxupquote{MovAvgFilter.py}} and \sphinxcode{\sphinxupquote{Main.py}}. The first file generates a signal (the true signal) which is a combination of 3 \(\sin\) waves and then adds random gaussian noise to this signal, the noisy signal. The second contains the filter algorithm which will be used to fit the noisy signal and the third runs the filter on the generated signal.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-9}.png}
\caption{Moving average filter applied to a noisy signal with \(n = 25\).}\label{\detokenize{1FilterBasics:fig-moving-average-k25}}\end{figure}

\sphinxAtStartPar
The moving average lags behind the true signal but has roughly the right shape. This is expected as the moving average relies on previous estimates.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-15}.png}
\caption{Moving average filter applied to a noisy signal with \(n=5\).}\label{\detokenize{1FilterBasics:fig-moving-average-k5}}\end{figure}

\sphinxAtStartPar
In this example the delay is smaller but less noise is removed. There is a tradeoff between noise reduction and minimizing delay limiting the accuracy of the moving average filter.


\section{1.3 Exponential Moving Average filter (Low Pass)}
\label{\detokenize{1FilterBasics:exponential-moving-average-filter-low-pass}}
\sphinxAtStartPar
All terms in \eqref{equation:1FilterBasics:eq-moving-average} have equal weighting (\(1/n\)), however it makes more sense to give more recent terms a larger weighting, this should help minimize delay whilst preserving the smoothing effect. A result of this is it allows low frequencies to pass through but filters out high frequencies. Noise is usually high frequency. Below is an example of a first order exponential moving average, low pass filter (EMALPF):
\begin{equation}\label{equation:1FilterBasics:eq-lowpass-1}
\begin{split}\hat{x}_k = \alpha \hat{x}_{k-1} + (1 - \alpha) z_k \quad 0<\alpha<1\end{split}
\end{equation}
\sphinxAtStartPar
Looks similar to \eqref{equation:1FilterBasics:eq-alpha} except here \(\alpha\) is a parameter to be tuned. It is also true that:
\begin{equation}\label{equation:1FilterBasics:eq-lowpass-2}
\begin{split}\hat{x}_{k-1} = \alpha \hat{x}_{k-2} + (1 - \alpha) z_{k-1} \quad 0<\alpha<1\end{split}
\end{equation}
\sphinxAtStartPar
Combining these equations helps to overcome some problems associated with the moving average since more distant terms disappear exponentially quickly:
\begin{equation}\label{equation:1FilterBasics:eq-lowpass-3}
\begin{split}\hat{x}_k = \alpha^2 \hat{x}_{k-2} + \alpha(1-\alpha) z_{k-1} + (1-\alpha)z_k \quad 0<\alpha<1\end{split}
\end{equation}
\sphinxAtStartPar
Due to the restriction on alpha larger \(n\) means greater weighting on \(\hat{x}_n\) since \(\alpha(1-\alpha)\leq 1-\alpha\). Previous data gets weighted exponentially less.

\sphinxAtStartPar
The code for this section can be found in \sphinxhref{https://github.com/MalachiHibbins/IMU/tree/main/2MovingAverageFilter}{github}. Similarly to the other two examples the code is made up of 3 files: \sphinxcode{\sphinxupquote{GenTestSig.py}}, \sphinxcode{\sphinxupquote{LowPassFilter.py}} and \sphinxcode{\sphinxupquote{Main.py}}. The first file generates a signal (the true signal) which is again a combination of 3 \(\sin\) waves and then adds random gaussian noise to this signal, the noisy signal. The second contains the filter algorithm which will be used to fit the noisy signal and the third runs the filter on the generated signal.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-10}.png}
\caption{Figure 3.1: EMALPF with optimized \(\alpha = 0.93\) (visually).}\label{\detokenize{1FilterBasics:fig-lowpass-vs-moving-average}}\end{figure}

\sphinxAtStartPar
The low pass filter has a smaller delay compared to the moving average filter, but was nosier. This makes sense as the moving average filter gives equal weight to all previous estimates, so noisy measurements will have a smaller effect on the fit.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-13}.png}
\caption{Figure 3.2: Low pass filter with \(\alpha = 0.8\).}\label{\detokenize{1FilterBasics:fig-lowpass-alpha-08}}\end{figure}

\sphinxAtStartPar
Here the delay is less significant but the filter doesn’t remove as much noise compared to \hyperref[\detokenize{1FilterBasics:fig-lowpass-vs-moving-average}]{Fig.\@ \ref{\detokenize{1FilterBasics:fig-lowpass-vs-moving-average}}}, since the weighting on previous estimates is smaller.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-14}.png}
\caption{Figure 3.3: Low pass filter with \(\alpha = 0.97\).}\label{\detokenize{1FilterBasics:fig-lowpass-alpha-095}}\end{figure}

\sphinxAtStartPar
Here the delay is more significant since previous results are given larger weightings. The choice of \(\alpha\) represents a tradeoff between a noisy signal and a delayed signal, which means its difficult to find optimal \(\alpha\).


\section{1.4 Exponential Moving Average Filter (High Pass)}
\label{\detokenize{1FilterBasics:exponential-moving-average-filter-high-pass}}
\sphinxAtStartPar
An exponential moving average high pass filter (EMAHPF) works by subtracting the EMALPF \(\hat{x}^{LP}_k\) from \(z_k\). This corresponds to removing the low frequencies from the signal. The high pass filter estimates the state \(\hat{x}^{HP}_k\) as:
\begin{equation}\label{equation:1FilterBasics:eq-highpass}
\begin{split}\hat{x}_k^{HP} = z_k - \hat{x}^{LP}_k \end{split}
\end{equation}
\sphinxAtStartPar
Subbing in \eqref{equation:1FilterBasics:eq-lowpass-1} gives:
\begin{equation}\label{equation:1FilterBasics:eq-highpass-2}
\begin{split}\hat{x}_k^{HP} = \alpha (\hat{x}^{LP}_{k-1} + z_k)\end{split}
\end{equation}
\sphinxAtStartPar
Then subbing \eqref{equation:1FilterBasics:eq-highpass} rearranged into \eqref{equation:1FilterBasics:eq-highpass-2} gives:
\begin{equation}\label{equation:1FilterBasics:eq-highpass-3}
\begin{split}\hat{x}_k^{HP} = \hat{x}_{k-1}^{HP} + z_k - z_{k-1}\end{split}
\end{equation}
\sphinxAtStartPar
Which is the recursive formula for the EMAHPF. These are useful for removing low frequency background noise, such as integration drift.


\section{1.5 Summary}
\label{\detokenize{1FilterBasics:summary}}
\sphinxAtStartPar
The above are examples of passive filters as they filter data without using feedback from a physical model. Kalman filters are active filters which compare measurements with feedback to determine an improved estimate of the state.

\sphinxstepscope


\chapter{2 Kalman filters}
\label{\detokenize{2KalmanFilters:kalman-filters}}\label{\detokenize{2KalmanFilters::doc}}
\sphinxAtStartPar
\sphinxstylestrong{A Kalman filter compares the predicted state, \(\hat{x}^-_k\), with measurements, \(z_k\), to create an estimate of the true state, \(\hat{x}_k\)}. This section introduces the Kalman filter, its algorithm and why its useful. The state is a vector that contains the variables required to describe the system at a specific time.

\begin{sphinxadmonition}{important}{Important:}
\sphinxAtStartPar
Predictions and estimates are not interchangeable when talking about Kalman filters. A prediction is a forecast of the next state based on the previous state and the mathematical model. Whereas a estimate is an update of the predicted state once new measurements have been taken.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
In all future sections scalars will be written as plain text \(a\) and vectors will be written in bold \(\boldsymbol{a}\). Here the symbols are context free so so are all in plain text.
\end{sphinxadmonition}


\section{2.1 Dictionary}
\label{\detokenize{2KalmanFilters:dictionary}}
\sphinxAtStartPar
The Kalman filter deals with the linear state model. Where the state evolves linearly according to \(A\):
\begin{equation}\label{equation:2KalmanFilters:state}
\begin{split}x_{k+1} = Ax_k + w_k\end{split}
\end{equation}
\sphinxAtStartPar
As long as no forcing function is present. The measurement can be described as:
\begin{equation}\label{equation:2KalmanFilters:measurement}
\begin{split}z_k = Hx_k + v_k \end{split}
\end{equation}
\sphinxAtStartPar
Where \(w_k\) and \(v_k\) are both distributed normally with mean \(0\).

\begin{sphinxShadowBox}
\sphinxstylesidebartitle{}

\sphinxAtStartPar
A forcing function is something external that \sphinxstylestrong{deliberately} changes how the system behaves. E.g. When modelling a car rolling down a hill the cars motion is determined by gravity. Applying the cars breaks would be an example of a forcing function.**
\end{sphinxShadowBox}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(x_k\) is the actual (but unknown) state vector at time \(t_k\) e.g. the true position and velocity of a car. \(x_k\). \sphinxstylestrong{\(n\times 1\) column vector}.

\item {} 
\sphinxAtStartPar
\(z_k\) is the measurement of the state from the sensor at time \(t_k\), but contains noise and errors e.g. the GPS position of the car. \sphinxstylestrong{\(m \times 1\) column vector}.

\item {} 
\sphinxAtStartPar
\(A\) is the state transition matrix. \(A\) represents the “rules of motion” of the system. It describes how \(\hat{x}_k\) evolves from one time step to the next, assuming there is no external factors changing it (a forcing function). For example if you knew a cars velocity at time \(t_k\) you could use \(A\) to predict where it would be at time \(t_{k+1}\). \sphinxstylestrong{\(n\times n\) matrix}.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
\(A\) isn’t always a constant matrix, it can be dependent on time, or measurements from other sensors.
\end{sphinxadmonition}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(\hat{x}_k\) and \(\hat{x}^-_k\) represent the best estimate and prediction of \(x_k\) respectively. \(\hat{x}^-_k\) is a prediction of the next state based on the physics of the system which is modeled using \(A\). \(\hat{x}_k\) is a updated estimate which blends the model based prediction \(\hat{x}^-_k\) and the measurement \(z_k\). \(\hat{x}_k\) is the end output from the Kalman filter.

\item {} 
\sphinxAtStartPar
\(H\) is the state to measurement matrix. \(H\) is the translator between the system’s state and what can be measured. It explains how, if there were no noise or errors, the true state would appear in the sensor. E.g. if the model uses position to predict velocity but the sensor only measures position how \(H\) only picks out position. \sphinxstylestrong{\(m \times n\) matrix}.

\item {} 
\sphinxAtStartPar
\(\hat{z}^-_k\) and \(\hat{z}_k\) is the what the model predicts and estimates the measurements should be respectively:

\end{itemize}
\begin{align}\label{equation:2KalmanFilters:eq-h-calculate}\!\begin{aligned}
\hat{z}_k &= H\hat{x}_k\\
\hat{z}^-_k &= H\hat{x}^-_k\\
\end{aligned}\end{align}
\sphinxAtStartPar
\eqref{equation:2KalmanFilters:eq-h-calculate} is useful for determining \(H\).
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(w_k\) is the linear process noise vector or noise associated with the prediction. \(w_k\) is white sequence noise (random noise uncorrelated with time), which makes the models prediction imperfect. E.g. unexpected bumps in the road for a moving car. \sphinxstylestrong{\(n \times 1\) column vector}.

\item {} 
\sphinxAtStartPar
\(v_k\) is the linear measurement noise vector, noise associated that corrupts \(z_k\). Even if the true state is fixed, the measurements can change due to sensor imperfections. E.g. temperature measurements using a thermometer will be slightly different each time you measure. \sphinxstylestrong{\(m \times 1\) column vector}.

\item {} 
\sphinxAtStartPar
\(Q\) is the covariance matrix of \(w_k\) i.e. how much the true state is expected to deviate from the predictions made by the state transition model. Large \(Q\) assumes the measurements are more reliable than the model and puts a larger weighting on \(z_k\) compared to \(\hat{x}^-_k\) when computing \(\hat{x}_{k+1}\). Smaller \(Q\) puts more trust in the model \(\hat{x}^-_k\) compared to \(z_k\). \sphinxstylestrong{\(n \times n\) matrix}.

\end{itemize}
\begin{equation}\label{equation:2KalmanFilters:eq-process-noise-cov}
\begin{split}Q_k = \mathbb{E}[w_k w_k^T]\end{split}
\end{equation}
\sphinxAtStartPar
{[}\hyperlink{cite.99Bibliography:id2}{BH12}{]} (chapter 4)
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(R\) is the covariance matrix of \(v_k\). i.e. how much the measured state is effected by noise in the state transition model. \(R\) tells the Kalman filter how much to “trust” the measurements compared to model predictions.  Large \(R\) suggests the model is more reliable than the measurements and puts more emphasis on \(\hat{x}^-_k\) compared to \(z_k\) when computing \(\hat{x}_{k+1}\), small \(R\) puts more emphasis on \(z_k\) compared to \(\hat{x}^-_k\). \sphinxstylestrong{\(m \times m\) matrix}.

\end{itemize}
\begin{equation}\label{equation:2KalmanFilters:eq-measurement-noise-cov}
\begin{split}R_k = \mathbb{E}[v_k v_k^T]\end{split}
\end{equation}
\sphinxAtStartPar
{[}\hyperlink{cite.99Bibliography:id2}{BH12}{]} (chapter 4)
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(e_k\) and \(e^-_k\) are the error in the estimation and the error in the prediction respectively defined as \(e_k = x_k-\hat{x}_k\) and \(e^-_k = x_k-\hat{x}^-_k\). \sphinxstylestrong{\(n \times 1\) column vector.}

\item {} 
\sphinxAtStartPar
\(P_k\) and \(P^-_k\) are the associated error covariance matrices for \(e_k\) and \(e^-_k\) respectively defined by: \sphinxstylestrong{\(n \times n\)} matrix.

\end{itemize}
\begin{equation}\label{equation:2KalmanFilters:eq-estimation-cov}
\begin{split}P_k = \mathbb{E}[e_k e_k^T]\end{split}
\end{equation}
\sphinxAtStartPar
and
\begin{equation}\label{equation:2KalmanFilters:eq-prediction-cov}
\begin{split}P^-_k = \mathbb{E}[e^-_k (e^-_k)^T]\end{split}
\end{equation}
\sphinxAtStartPar
{[}\hyperlink{cite.99Bibliography:id2}{BH12}{]} (chapter 4)
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(K_k\) is the Kalman gain which has similar effects to \(\alpha\) in the low pass filter. \sphinxstylestrong{\(n \times m\) matrix}. It is a blending factor that determines how much of the prediction and measurement goes into the updated estimate \(\hat{x}_k\). The Kalman gain is determined by the covariance matrices \(P^-_k\), \(H\), \(R\) and \(Q\).

\item {} 
\sphinxAtStartPar
\(x_0\) is the initial state estimate. provided at the start of the estimation process.

\item {} 
\sphinxAtStartPar
\(P_0\) is the initial error covariance matrix estimate.

\end{itemize}

\begin{sphinxadmonition}{important}{Important:}
\sphinxAtStartPar
The Kalman filter parameters are the parameters set by the user before fitting the data they are: \(A\), \(Q\), \(H\), \(R\), \(\hat{x}_0\) and \(P_0\).
\end{sphinxadmonition}


\section{2.2 Estimation step}
\label{\detokenize{2KalmanFilters:estimation-step}}
\sphinxAtStartPar
The prediction \(\hat{x}^-_k\) and measurement are combined using the blending factor \(K_k\) (yet to be determined) below to determine the updated estimate \(\hat{x}_k\).
\begin{equation}\label{equation:2KalmanFilters:eq-kalman-update}
\begin{split}\hat{x}_k = \hat{x}^-_k + K_k(z_k - H\hat{x}^-_k)\end{split}
\end{equation}
\sphinxAtStartPar
this is known as the \sphinxstylestrong{update step} \(K_k\) determines how much of each \(z_k\) and \(\hat{x}^-_k\) goes into \(\hat{x}_k\) i.e. how much the measurement is trusted compared to the prediction.

\begin{sphinxadmonition}{note}{Aside: Connection between Kalman filter and low pass filter}

\sphinxAtStartPar
Equation \eqref{equation:2KalmanFilters:eq-kalman-update} can be rewritten as:
\begin{equation}\label{equation:2KalmanFilters:eq-kalman-lowpass}
\begin{split}\hat{x}_k = (\mathbb{I} + K_k H)\hat{x}^-_k + K_k z_k\end{split}
\end{equation}
\sphinxAtStartPar
Letting \(H = \mathbb{I}\) and \(\alpha= 1-K_k\) a first order low pass filter is recovered similar to \eqref{equation:1FilterBasics:eq-lowpass-2}.
\begin{equation}\label{equation:2KalmanFilters:eq-kalman-alpha}
\begin{split}\hat{x}_k = \alpha \hat{x}^-_{k} + (1 - \alpha) z_k\end{split}
\end{equation}
\sphinxAtStartPar
A low pass filter smooths out noisy data by blending the previous estimate with new data using a fixed weighting factor \(\alpha\). The Kalman filter automatically adjusts its version of \(\alpha\) essentially \(K_k\) to decide how to weight the previous estimate and the new data for each time step depending on how much uncertainty there is in the prediction and measurement.
\end{sphinxadmonition}

\sphinxAtStartPar
The mean square error (MSE) between \(\hat{x}_k\) and \(x_k\) is the performance criterion for the Kalman filter. The MSE is related to the terms in the leading diagonal of \(P_k\). Here an expression for \(K_k\) is derived that minimizes the MSE. An expression from the definition of \(P_k\) from \eqref{equation:2KalmanFilters:eq-estimation-cov} in terms of our Kalman parameters is required. The problem is \eqref{equation:2KalmanFilters:eq-estimation-cov} contains \(e_k\) which can’t be computed since \(x_k\) is unknown.

\sphinxAtStartPar
First an expression for \(\hat{x}_k\)  was determined by subbing \eqref{equation:2KalmanFilters:measurement} into \eqref{equation:2KalmanFilters:eq-kalman-update}, to rewrite the estimation update equation:
\begin{equation}\label{equation:2KalmanFilters:eq-intermediate-step}
\begin{split}\hat{x}_k = \hat{x}^-_k + K_k(Hx_k+v_k-H\hat{x}^-_k)\end{split}
\end{equation}
\sphinxAtStartPar
then an expression for \(P_k\) was obtained by subbing \eqref{equation:2KalmanFilters:eq-intermediate-step} into \eqref{equation:2KalmanFilters:eq-estimation-cov}:
\begin{equation}\label{equation:2KalmanFilters:eq-expectation}
\begin{split}P_k = \mathbb{E} \left\{ 
\left[ 
(x_k - \hat{x}_k^-) - K_k \left( H_k {x}_k + v_k - H_k \hat{x}_k^- \right)
\right]
\left[ 
(x_k - \hat{x}_k^-) - K_k \left( H_k {x}_k + v_k - H_k \hat{x}_k^- \right)
\right]^T
\right\}\end{split}
\end{equation}
\begin{sphinxadmonition}{note}{In depth expectation simplification}

\sphinxAtStartPar
By comparing \eqref{equation:2KalmanFilters:eq-expectation} and \eqref{equation:2KalmanFilters:eq-estimation-cov} the estimation error \(e_k\) is built from the error in prediction and the error effect of measurement noise. The estimation error after the update step is:
\begin{equation}\label{equation:2KalmanFilters:eq-E1}
\begin{split}e_k = (x_k - \hat{x}_k^-) - K_k \left( H_k {x}_k + v_k - H_k \hat{x}_k^- \right)\end{split}
\end{equation}
\sphinxAtStartPar
Initially \(e_k\) is the error between the true state and the prediction. The Kalman gain adjusts this based on what is actually measured \(z_k = H_k {x}_k + v_k\) and what the expected measurment is \(\hat{z} = H_k \hat{x}_k^-\) based on the model.
Grouping the terms more intuitively by substituting in the definition for the prediction error \(e^-_k = x_k - \hat{x}_k^-\) gets:
\begin{equation}\label{equation:2KalmanFilters:eq-E2}
\begin{split}e_k = e^-_k \Omega_k - K_kv_k\end{split}
\end{equation}
\sphinxAtStartPar
Where \(\Omega_k = I - K_k H_k\) describes how much of the prediction error remains after the update. Subbing \eqref{equation:2KalmanFilters:eq-E2} into \eqref{equation:2KalmanFilters:eq-estimation-cov} gives:
\begin{equation}\label{equation:2KalmanFilters:eq-E3}
\begin{split}P_k = \mathbb{E}[(e^-_k \Omega_k - K_kv_k)(e^-_k\Omega_k - K_kv_k)^T]\end{split}
\end{equation}
\sphinxAtStartPar
After expanding the brackets 4 terms are obtained:
\begin{equation}\label{equation:2KalmanFilters:eq-E4}
\begin{split}P_k = \mathbb{E}[ 
\Omega_k, e^-_k (e^-_k)^T \Omega_k^T 
- \Omega_k, e^-_k v^T K_k^T 
- K_k v (e^-_k)^T \Omega^T 
+ K_k v v^T K_k^T]\end{split}
\end{equation}
\sphinxAtStartPar
Then using the useful identity \(\mathbb{E}[Ax + By] \equiv A\mathbb{E}[x] + B \mathbb{E}[y]\) \eqref{equation:2KalmanFilters:eq-E4} can be rewritten:
\begin{equation}\label{equation:2KalmanFilters:eq-E5}
\begin{split}P_k =  
\Omega_k, \mathbb{E}[e^-_k (e^-_k)^T] \Omega_k^T 
- \Omega_k \mathbb{E}[e^-_k v^T] K_k^T
- K_k \mathbb{E}[v (e^-_k)^T] \Omega^T 
+ K_k \mathbb{E}[v v^T] K_k^T\end{split}
\end{equation}
\sphinxAtStartPar
The first term represents the uncertainty left from the prediction after the update. The last term represents the uncertainty added by the measurement noise. The two middle terms represent the interaction between the prediction error and the measurement noise they are both zero since \(e_k\) and \(v_k\) are both have mean of \(0\) and are independent. Subbing in \eqref{equation:2KalmanFilters:eq-prediction-cov} into the first term, \eqref{equation:2KalmanFilters:eq-measurement-noise-cov} into the last and our definition of \(\Omega_k\) term gets \eqref{equation:2KalmanFilters:P_k-minimise}.
\end{sphinxadmonition}

\sphinxAtStartPar
Performing the expectations leaves an equation for \(P_k\) in terms of Kalman filter parameters:
\begin{equation}\label{equation:2KalmanFilters:P_k-minimise}
\begin{split}P_k = (I-K_kH_k)P^-_k(I-K_kH_k)^T+K_kR_kK^T_k\end{split}
\end{equation}
\sphinxAtStartPar
Which is a general expression for the updated error covariance matrix for suboptimal \(K_k\). Now optimize \(K_k\) by minimizing the MSE corresponding to finding the value of \(K_k\) that minimizes the individual terms along the leading diagonal of \(P_k\) as these terms represent the estimation error variances for the elements of the state vector elements being selected. This leaves:

\begin{sphinxShadowBox}
\sphinxstylesidebartitle{}

\sphinxAtStartPar
For a more detailed derivation see {[}\hyperlink{cite.99Bibliography:id2}{BH12}{]} (chapter 4).
\end{sphinxShadowBox}
\begin{equation}\label{equation:2KalmanFilters:eq-kalman-gain}
\begin{split}K_k = P^-_k H^T (H P^-_k H^T + R)^{-1}\end{split}
\end{equation}
\sphinxAtStartPar
In this case \(K_k\) is the optimum Kalman gain. When considering the optimum Kalman gain \eqref{equation:2KalmanFilters:P_k-minimise} can be simplified by ignoring the last two terms:
\begin{equation}\label{equation:2KalmanFilters:eq-error-covariance-update}
\begin{split}P_k = P^-_k - K_k H P^-_k\end{split}
\end{equation}
\sphinxAtStartPar
{[}\hyperlink{cite.99Bibliography:id2}{BH12}{]} (chapter 4).

\sphinxAtStartPar
Whereas the low pass filter passes \(\hat{x}_{k-1}\) directly between time steps \(t_{k-1}\) and \(t_{k}\) the Kalman filter predicts the next step before a measurement is carried out and compares this with the measurement to give new estimate.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
\(H\) and \(R\) are only used in the prediction step.
\end{sphinxadmonition}

\sphinxAtStartPar
The equations \eqref{equation:2KalmanFilters:eq-kalman-update}, \eqref{equation:2KalmanFilters:eq-kalman-gain} and \eqref{equation:2KalmanFilters:eq-error-covariance-update} together describe the estimation step of the Kalman filter.


\section{2.3 Prediction step}
\label{\detokenize{2KalmanFilters:prediction-step}}
\sphinxAtStartPar
Unlike the low pass filter Kalman filters also consider the physics of the system, the predictions which are used alongside measurements for state estimation. The system dynamically changes over time and is modelled using \(A\), which describes how the state is predicted to change between \(t_k\) and \(t_{k+1}\):
\begin{equation}\label{equation:2KalmanFilters:projection}
\begin{split}\hat{x}^-_{k+1} = A \hat{x}_k\end{split}
\end{equation}
\sphinxAtStartPar
The error covariance matrix associated with this prediction \(\hat{x}^-_{k+1}\) is obtained from:

\begin{sphinxShadowBox}
\sphinxstylesidebartitle{}

\sphinxAtStartPar
If \(\mu_x\) is transformed linearly \(\mu_y = F\mu_x\) its covariance matrix, \(\Sigma_x\), can be transformed using \(\Sigma_y = F\Sigma_xF^T\). {[}\hyperlink{cite.99Bibliography:id3}{BAOOl21}{]} (chapter 2)
\end{sphinxShadowBox}
\begin{equation}\label{equation:2KalmanFilters:projection-covariance}
\begin{split}P^-_k = AP_kA^T+Q\end{split}
\end{equation}
\sphinxAtStartPar
\(Q\) also appears here as this is how much the true state is expected to vary from the predictions. Together equations \eqref{equation:2KalmanFilters:projection} and \eqref{equation:2KalmanFilters:projection-covariance} equations encode the prediction phase of the filter.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
\(A\) and \(Q\) are only used in the prediction step.
\end{sphinxadmonition}


\section{2.4 Summary}
\label{\detokenize{2KalmanFilters:summary}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{BasicKalman}.jpg}
\caption{Block diagram of the Kalman filter process.}\label{\detokenize{2KalmanFilters:fig-kalman-block-diagram}}\end{figure}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(A\) and \(H\) are essential for the Kalman filter if these are incorrect the filter will not converge.

\item {} 
\sphinxAtStartPar
\(Q\) and \(R\) are used for tuning and ensure an optimum fit.

\item {} 
\sphinxAtStartPar
\(x_0\) and \(P_0\) are initial estimates the filter will still converge even if these are wrong.

\item {} 
\sphinxAtStartPar
\(K_k\) and \(P_k\) are internal parameters.

\item {} 
\sphinxAtStartPar
\(z_k\) are the inputs (measured state)

\item {} 
\sphinxAtStartPar
\(\hat{x}_k\) are the outputs (estimated state)

\end{itemize}

\sphinxstepscope


\chapter{3 Example: Battery output}
\label{\detokenize{3ExampleBatteryOutput:example-battery-output}}\label{\detokenize{3ExampleBatteryOutput::doc}}
\sphinxAtStartPar
This example looks at how a Kalman filter can be used to fit a constant signal in this case the output from a battery. The aim of this simple example is to experiment with changing the Kalman parameters \(A\), \(H\), \(Q\), \(R\), \(\hat{x}_0\) and \(P_0\). This example was inspired by Dr Shane Ross a link to the video can be found \sphinxhref{https://www.youtube.com/watch?v=qCZ2UTgLM\_g\&amp;t=1527s}{here}.


\section{3.1 Model}
\label{\detokenize{3ExampleBatteryOutput:model}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\(\hat{x}_k\) is the estimate of the true battery output in volts, \(n = 1\),

\item {} 
\sphinxAtStartPar
\(z_k\) is the measured battery output in volts, \(m=1\)
In this very simple example \(A\), \(H\), \(Q\) and \(R\) are all scalars since \(m=n=1\)

\item {} 
\sphinxAtStartPar
\(A=1\) the battery output is constant which means \(x_{k+1}\) = \(x_k\) comparing with \eqref{equation:2KalmanFilters:projection} shows \(A = 1\)

\item {} 
\sphinxAtStartPar
\(Q = 0\) Since the battery output is known to be constant.

\item {} 
\sphinxAtStartPar
\(H = 1\) since estimate corresponds directly to measurement see \eqref{equation:2KalmanFilters:eq-h-calculate}.

\item {} 
\sphinxAtStartPar
\(R = 4\) initially but was determined through tuning.

\item {} 
\sphinxAtStartPar
\(x_0\) was set to 5

\item {} 
\sphinxAtStartPar
\(P_0\) was set to 1

\end{itemize}


\section{3.2 Testing}
\label{\detokenize{3ExampleBatteryOutput:testing}}
\sphinxAtStartPar
The code for this example can be found \sphinxhref{https://github.com/MalachiHibbins/IMU/tree/main/4aSimpleKalman}{here}. The code is broken up into 3 files: \sphinxcode{\sphinxupquote{GenTestSig.py}} which generates the true signal (a constant value) and adds gaussian noise to it; \sphinxcode{\sphinxupquote{SimpleKalman.py}} contains the algorithm for the kalman filter for the 1D case; and \sphinxcode{\sphinxupquote{TestWidget.py}} calls functions from the other files and plots the results, with a widget so the effects of the kalman parameters can be easily visualized.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-2}.png}
\caption{Kalman filter used to fit a non\sphinxhyphen{}varying signal with a large amount of noise.}\label{\detokenize{3ExampleBatteryOutput:fig-kalman-constant}}\end{figure}

\sphinxAtStartPar
\hyperref[\detokenize{3ExampleBatteryOutput:fig-kalman-constant}]{Fig.\@ \ref{\detokenize{3ExampleBatteryOutput:fig-kalman-constant}}} shows that convergence is faster and smoother than the average filter. This makes sense as the kalman filter looks at both the model and the data to reduce noise.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-3}.png}
\caption{\hyperref[\detokenize{3ExampleBatteryOutput:fig-kalman-constant}]{Fig.\@ \ref{\detokenize{3ExampleBatteryOutput:fig-kalman-constant}}} but with smaller \(R\).}\label{\detokenize{3ExampleBatteryOutput:fig-small-r}}\end{figure}

\sphinxAtStartPar
\hyperref[\detokenize{3ExampleBatteryOutput:fig-small-r}]{Fig.\@ \ref{\detokenize{3ExampleBatteryOutput:fig-small-r}}} shows smaller \(R\) makes convergence less smooth. This puts more faith in noisy \(z_k\) compared to less noisy \(\hat{x}^-_k\) so in the correction stage of the kalman filter more emphasis will be put on noisy \(z_k\) than on less noisy \(\hat{x}^-_k\). The signal will converge faster when \(R\) is smaller as the initial guess is far from \(x_k\), this means initially \(x^-_k\) will be less accurate than \(z_k\) since the prediction phase assumes that \(\hat{x}^-_{k} = \)\textbackslash{}hat\{x\sphinxhyphen{}1\}\_k\$ which for the initial guess is incorrect. The downside of this is that the signal is more effected by noise.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-4}.png}
\caption{\hyperref[\detokenize{3ExampleBatteryOutput:fig-kalman-constant}]{Fig.\@ \ref{\detokenize{3ExampleBatteryOutput:fig-kalman-constant}}} but with larger \(R\).}\label{\detokenize{3ExampleBatteryOutput:fig-larger-r}}\end{figure}

\sphinxAtStartPar
\hyperref[\detokenize{3ExampleBatteryOutput:fig-larger-r}]{Fig.\@ \ref{\detokenize{3ExampleBatteryOutput:fig-larger-r}}} shows slower convergence than figures 4.1 and 4.2 but has the smoothest convergence of the three. \hyperref[\detokenize{3ExampleBatteryOutput:fig-kalman-constant}]{Fig.\@ \ref{\detokenize{3ExampleBatteryOutput:fig-kalman-constant}}} seems to be best as it has a good tradeoff between a noise free filtered signal and fast convergence.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-5}.png}
\caption{\hyperref[\detokenize{3ExampleBatteryOutput:fig-kalman-constant}]{Fig.\@ \ref{\detokenize{3ExampleBatteryOutput:fig-kalman-constant}}} with H set to \(1.115\) rather than \(1\)}\label{\detokenize{3ExampleBatteryOutput:figu-kalman-wrong-h}}\end{figure}

\sphinxAtStartPar
Varying \(H\) will lead to the Kalman filter converging to the wrong value since the measurement directly measures the state only satisfied by \(H = 1\).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-6}.png}
\caption{\hyperref[\detokenize{3ExampleBatteryOutput:fig-kalman-constant}]{Fig.\@ \ref{\detokenize{3ExampleBatteryOutput:fig-kalman-constant}}} with \(A\) set to 1.004 rather than 1.}\label{\detokenize{3ExampleBatteryOutput:fig-kalman-a-1004}}\end{figure}

\sphinxAtStartPar
This causes the Kalman filter to diverge since only \(A=1\) describes a straight line. It diverges quickly since \(Q=0\) puts more weighting on \(\hat{x}_k\) compared to \(\hat{z_k}\).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-7}.png}
\caption{\hyperref[\detokenize{3ExampleBatteryOutput:fig-kalman-constant}]{Fig.\@ \ref{\detokenize{3ExampleBatteryOutput:fig-kalman-constant}}} except with \(Q = 0.817\) rather than 1.}\label{\detokenize{3ExampleBatteryOutput:fig-kalman-q-0817}}\end{figure}

\sphinxAtStartPar
Setting \(Q\) to anything other than \(0\) in this example makes the filtered signal noisy, because it assumes the model is noisy. Increasing \(Q\) puts more trust \(\hat{z}_k\) over \(\hat{x}^-_{k}\) when predicting \(\hat{x}_k\) which means the signal becomes noisy like the data.


\section{3.3 Summary}
\label{\detokenize{3ExampleBatteryOutput:summary}}
\sphinxAtStartPar
\(A\) describes the model and \(H\) describes how the measurement relates to the state. If these are incorrect the fit will converge to the wrong value or diverge completely. \(Q\) and \(R\) are covariance matrices, these are “tuned” to achieve optimum fit.

\sphinxstepscope


\chapter{4 Example: Velocity from position}
\label{\detokenize{4ExampleVelocityFromPosition:example-velocity-from-position}}\label{\detokenize{4ExampleVelocityFromPosition::doc}}
\sphinxAtStartPar
This example looks at applying a Kalman filter to estimate the true position and velocity from noisy position data. This example was inspired by Dr Shane Ross a link to the videos are here: \sphinxhref{https://www.youtube.com/watch?v=qCZ2UTgLM\_g\&amp;t=1527s}{Video 1} and \sphinxhref{https://www.youtube.com/watch?v=DbE4PMgqp3s\&amp;t=2152s}{Video 2}.


\section{4.1 Model}
\label{\detokenize{4ExampleVelocityFromPosition:model}}
\sphinxAtStartPar
In this case \(\hat{\boldsymbol{x}}_k = \begin{bmatrix} s_k \\ \nu_k \end{bmatrix}\) where \(s_k\) and \(\nu_k\) are the position and velocity (in the same direction) respectively at time \(t_k\).  The correction measurement is position therefore \(z_k = s_k\). The measurement and the state are related by \eqref{equation:2KalmanFilters:eq-h-calculate} from this \(H\) can be calculated.
\begin{equation}\label{equation:4ExampleVelocityFromPosition:H}
\begin{split}z_k &= H \begin{bmatrix} s_k \\ \nu_k \end{bmatrix} \\
\implies H &= \begin{bmatrix} 1 & 0 \end{bmatrix}\end{split}
\end{equation}
\sphinxAtStartPar
For simplicity and to avoid needing to use a forcing function the model assumes no acceleration. The equations of motion are:
\begin{equation}\label{equation:4ExampleVelocityFromPosition:eq-motion-equations}
\begin{split}s_{k+1} &\approx s_k + \nu_k\Delta t \\
\nu_{k+1} &\approx \nu_k\end{split}
\end{equation}
\begin{sphinxadmonition}{note}{why use \protect\(\approx\protect\) not \protect\(=\protect\)}

\sphinxAtStartPar
There is a small error associated with discretizing \(dt\) since \(\Delta t\) isn’t infinitesimally small. This is negligible term to term but over a large number of terms such as in this example the error accumulates and causes drift.
\end{sphinxadmonition}

\sphinxAtStartPar
Where \(\Delta t = t_{k+1} - t_k\). Now writing the update equations in matrix form the following are obtained:
\begin{equation}\label{equation:4ExampleVelocityFromPosition:velocity}
\begin{split}\begin{bmatrix} s \\ \nu \end{bmatrix}^-_{k+1} = \begin{bmatrix} 1 & \Delta t \\ 0 & 1 \end{bmatrix} \begin{bmatrix} s \\ \nu \end{bmatrix}_k\end{split}
\end{equation}
\sphinxAtStartPar
\(Q\) is more complicated to calculate and is going to be a \(2 \times 2\) matrix of the form below:
\begin{equation*}
\begin{split}Q = E[w_kw_k^T] =  \begin{bmatrix} VAR(s) & COV(s,\nu) \\ COV(\nu,s) & VAR(\nu) \end{bmatrix} = \sigma_Q^2 \begin{bmatrix} \frac{\Delta t^4}{4} & \frac{\Delta t^3}{2} \\ \frac{\Delta t^3}{2} & \Delta t^2 \end{bmatrix} \end{split}
\end{equation*}
\sphinxAtStartPar
{[}\hyperlink{cite.99Bibliography:id3}{BAOOl21}{]} (chapter 2.3) {[}\hyperlink{cite.99Bibliography:id3}{BAOOl21}{]} (chapter 10.2)
where \(\sigma_Q^2\) is the variance in the true acceleration, which is the model assumes is zero. \(\sigma_Q^2\) will be used as a tuning parameter.
\(R = VAR(z_k)\) is going to be the variance in the measurements of the position which will be denoted as \(\sigma_R\) {[}\hyperlink{cite.99Bibliography:id3}{BAOOl21}{]} (chapter 10).

\sphinxAtStartPar
The following parameters will be used for the Kalman filter.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(\hat{\boldsymbol{x}}_k = \begin{bmatrix} s_k \\ \nu_k \end{bmatrix}\)

\item {} 
\sphinxAtStartPar
\(z_k = s_k\)

\item {} 
\sphinxAtStartPar
\(A = \begin{bmatrix} 1 & \Delta t \\ 0 & 1 \end{bmatrix}\)

\item {} 
\sphinxAtStartPar
\(H = \begin{bmatrix} 1 & 0 \end{bmatrix}\)

\item {} 
\sphinxAtStartPar
\(Q\) and \(R\) will are tuned using the parameters \(\sigma_a\) and \(\sigma_s\).

\item {} 
\sphinxAtStartPar
\(\boldsymbol{\hat{x}}_0 = \boldsymbol{0}\) and \(P_0 \approx \begin{bmatrix} P_s & 0 \\ 0 & P_v\end{bmatrix}\) initially, these don’t matter so much as the Kalman filter will eventually find the correct values as \(k\) increases.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
While optimal \(P_0\) isn’t necessarily always diagonal matrix this is a good enough initial approximation as the kalman filter will converge if \(A\) and \(H\) are correct.
\end{sphinxadmonition}


\section{4.2 Implementation}
\label{\detokenize{4ExampleVelocityFromPosition:implementation}}
\sphinxAtStartPar
The code for this example can be found \sphinxhref{https://github.com/MalachiHibbins/IMU/tree/main/4bIntermKalman}{here}. The code is broken up into 3 files: \sphinxcode{\sphinxupquote{GenTestSig.py}} which generates the true signal (a combination of sine waves of different frequencies) and adds gaussian noise to it; \sphinxcode{\sphinxupquote{AdvKalman.py}} contains the algorithm for the Kalman filter for the multidimensional case; and \sphinxcode{\sphinxupquote{TestUpdated.py}} calls functions from the other files and plots the results, with a widget so the effects of the Kalman parameters can be easily visualized.

\sphinxAtStartPar
The true signal in the graphs below is generated using a combination of \(\sin\) waves of varying amplitudes and speeds, the velocity version is the analytical derivative of this. The signal the Kalman filter is being used to fit is generated by adding random noise to the true signal and its analytical derivative. The Kalman filter is applied to the noisy position data and outputs the filtered position data and filtered velocity data. Which are graphed below.
The \(r^2\) value, mean squared error (MSE) and mean absolute error (MAE) are given for both velocity and position.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-23}.png}
\caption{Filtered, unfiltered and true position and velocity plotted against index.}\label{\detokenize{4ExampleVelocityFromPosition:fig-original}}\end{figure}

\sphinxAtStartPar
In both cases the kalman filtered fit is lagging behind the true and noisy signal. This is because too much emphasis is being put on the predicted values which assumes that velocity stays the same. The true signal shows this clearly this isn’t the case. This means the velocity prediction is consistently delayed so the position will also be delayed. Since the model is erroneous it was assumed that \(w_k\) was larger and therefore \(\sigma_Q\) should be increased. A similar effect can be achieved by assuming smaller measurement noise (smaller \(v_k\)) therefore \(\sigma_R\) should be decreased.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-24}.png}
\caption{See \hyperref[\detokenize{4ExampleVelocityFromPosition:fig-original}]{Fig.\@ \ref{\detokenize{4ExampleVelocityFromPosition:fig-original}}} with increased \(\sigma_Q\) and decreased \(\sigma_R\).}\label{\detokenize{4ExampleVelocityFromPosition:fig-increased-r-and-increased-q}}\end{figure}

\sphinxAtStartPar
Figure \hyperref[\detokenize{4ExampleVelocityFromPosition:fig-increased-r-and-increased-q}]{Fig.\@ \ref{\detokenize{4ExampleVelocityFromPosition:fig-increased-r-and-increased-q}}} shows a slightly improved fit with position and a significantly improved fit with velocity. This makes sense for the position data since decreasing \(R\) increases the weighting for the measurement. However the velocity fit is now significantly less smooth since more emphasis is being put on the measured positions which is always nosier than the prediction. There is a clear tradeoff between having a a smooth fit and having an accurate fit. Smoother fits more accurately represent the true shape of the data, but will often result often this comes with drift.

\begin{sphinxadmonition}{important}{Important:}
\sphinxAtStartPar
If the Kalman filter fit is too noisy, due to an over emphasis on \(\hat{z}_k\) compared to \(\hat{x}^-_k\) to calculate \(\hat{x}_{k}\) increasing \(R\) or decreasing \(Q\) will make the fit smoother. If the Kalman filter fit is delayed increasing \(Q\) or decreasing \(R\) will reduce the delay. Increasing \(Q\) has a similar effect to decreasing \(R\).
\end{sphinxadmonition}


\section{4.3 Summary}
\label{\detokenize{4ExampleVelocityFromPosition:summary}}
\sphinxAtStartPar
The kalman filter does a good job of estimating the true position from the data and the model. The velocity fit is less accurate and significantly delayed, but is good considering there are no measurements for the velocity. The fit for velocity would be greatly improved using an additional sensor to easily measure velocity or acceleration to be used in the prediction step.

\sphinxstepscope


\chapter{5 Example: Attitude using a gyroscope and accelerometer}
\label{\detokenize{5IMU:example-attitude-using-a-gyroscope-and-accelerometer}}\label{\detokenize{5IMU::doc}}
\sphinxAtStartPar
This section calculating the attitude of an object (yaw\sphinxhyphen{}pitch\sphinxhyphen{}roll), using real world sensor data. Firstly using the gyroscope to measure the angular velocity and then using Euler’s method for integration to obtain a prediction for the attitude, then improving this using a kalman filter, however this estimate drifts and becomes less accurate over time. To reduce drift accelerometer is used and the Kalman filter fuses data from the accelerometer and gyroscope.

\sphinxAtStartPar
The code for this section can be found in \sphinxhref{https://github.com/MalachiHibbins/IMU/tree/main/5IMU}{here}. The code is broken up into 3 files: \sphinxcode{\sphinxupquote{Test.py}} which runs the filter and plots the results; \sphinxcode{\sphinxupquote{AdvKalman.py}} which contains the kalman filter algorithm; and \sphinxcode{\sphinxupquote{Integrate.py}} which contains the integration algorithm which calculates the attitude without the kalman filter.

\sphinxAtStartPar
This example and data was provided by Dr Shane Ross a link to the video can be found \sphinxhref{https://www.youtube.com/watch?v=DbE4PMgqp3s\&amp;t=2152s}{here}.


\section{5.1 Euler’s method}
\label{\detokenize{5IMU:euler-s-method}}
\sphinxAtStartPar
Using gyroscope (measures angular velocity, \(\boldsymbol{\omega}\)) and knowing the attitude at \(t_0\) it is possible to determine the attitude of a craft at \(t_k\). The relationship between the body angular velocity \(\boldsymbol{\omega} = (\omega_1, \omega_2, \omega_3)\) and the time derivatives of the Euler angles \(\boldsymbol{\alpha} = (\psi, \theta, \phi)\) in the 3\sphinxhyphen{}2\sphinxhyphen{}1 (yaw\sphinxhyphen{}pitch\sphinxhyphen{}roll) sequence is given by the kinematic differential equation (KDE) below:

\begin{sphinxShadowBox}
\sphinxstylesidebartitle{}

\sphinxAtStartPar
\(\phi\), \(\theta\) and \(\psi\) are euler angles that describe the orientation of the object in space. Whereas \(\omega_1\), \(\omega_2\), \(\omega_3\)  are rates of rotation i.e. roll rate pitch rate and yaw rate.

\sphinxAtStartPar
\(\psi\), yaw: measures the rotation around the vertical (z) axis e.g. turning your head left and right in a “no” motion

\sphinxAtStartPar
\(\theta\), pitch: measures the rotation around the sided\sphinxhyphen{}to\sphinxhyphen{}side (y) axis e.g. nodding your head up and down in a “yes” motion.

\sphinxAtStartPar
\(\phi\), roll: rotation around the front\sphinxhyphen{}to\sphinxhyphen{}back (x) axis. E.g tilting your head to touch your ear to your shoulder.

\sphinxAtStartPar
The Euler angle rates \(\dot{\phi}\), \(\dot{\theta}\), \(\dot{\psi}\) are not the same as body angular rates because the orientation of the body axes changes as the object rotates.
\end{sphinxShadowBox}
\begin{equation}\label{equation:5IMU:H}
\begin{split}\begin{bmatrix}
\dot{\psi} \\
\dot{\theta} \\
\dot{\phi}
\end{bmatrix} =
\frac{1}{\cos{\theta}}\begin{bmatrix}
0 & \sin\phi  & \cos\phi  \\
0 & \cos\phi\cos\theta & -\sin\phi\cos\theta \\
\cos\theta & \sin\phi\sin\theta & \cos\phi  \sin\theta
\end{bmatrix}
\begin{bmatrix}
\omega_1 \\
\omega_2 \\
\omega_3
\end{bmatrix}\end{split}
\end{equation}
\sphinxAtStartPar
Or more simply :
\begin{equation}\label{equation:5IMU:eq-simple}
\begin{split}\dot{\boldsymbol{\alpha}} = \Phi(\boldsymbol{\alpha}) {\boldsymbol{\omega}}\end{split}
\end{equation}
\sphinxAtStartPar
where \(\Phi(\boldsymbol{\alpha}) = \frac{1}{\cos{\boldsymbol{\theta}}}\begin{bmatrix}
0 & \sin\phi  & \cos\phi  \\
0 & \cos\phi\cos\theta & -\sin\phi\cos\theta \\
\cos\theta & \sin\phi\sin\theta & \cos\phi  \sin\theta
\end{bmatrix}\)

\sphinxAtStartPar
The rates of rotation (provided by the gyroscope) are integrated step by step to predict the craft’s attitude at any later time \(t_k\):
\begin{equation}\label{equation:5IMU:eq-euler}
\begin{split}\boldsymbol{\alpha}_{k+1} \approx \boldsymbol{\alpha}_k + \dot{\boldsymbol{\alpha}}_k \Delta t\end{split}
\end{equation}
\sphinxAtStartPar
Subbing the relationship between \(\dot{\alpha}_k\) and \(\omega\) \eqref{equation:5IMU:eq-simple} into the update rule \eqref{equation:5IMU:eq-euler} gives:
\begin{equation}\label{equation:5IMU:euler-method2}
\begin{split}\boldsymbol{\alpha}_{k+1} \approx \boldsymbol{\alpha}_{k} + \Phi(\boldsymbol{\alpha}_k) \boldsymbol{\omega}_k \Delta t\end{split}
\end{equation}
\sphinxAtStartPar
where \(\Delta t = t_k - t_{k-1}\).

\begin{sphinxadmonition}{note}{why use \protect\(\approx\protect\) not \protect\(=\protect\)}

\sphinxAtStartPar
There is a small error associated with discretizing \(dt\) since \(\Delta t\) isn’t infinitesimally small. This is negligible term to term but over a large number of terms such as in this example the error accumulates and causes drift.
\end{sphinxadmonition}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-25}.png}
\caption{Calibration signal involved shaking the device in just the \(\omega_1\) direction then pausing and shaking the device in the \(\omega_1\) and \(\omega_2\) directions before pausing again and shaking the device in the \(\omega_3\). The observed motion in the \(\omega_3\) direction was erroneous. \sphinxhref{https://github.com/MalachiHibbins/IMU/tree/main/5IMU}{View in Github}}\label{\detokenize{5IMU:cal1}}\end{figure}

\sphinxAtStartPar
Using the calibration data in \hyperref[\detokenize{5IMU:cal1}]{Fig.\@ \ref{\detokenize{5IMU:cal1}}} and knowing the initial attitude \eqref{equation:5IMU:euler-method2} can be used to estimate the attitude over time:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-26}.png}
\caption{\(\boldsymbol{\alpha}_k\) in each direction plotted against \(t_k\). \sphinxhref{https://github.com/MalachiHibbins/IMU/tree/main/5IMU}{View in Github}}\label{\detokenize{5IMU:roll-pitch-yaw-drift-real}}\end{figure}

\sphinxAtStartPar
Overall the attitude \(\boldsymbol{\alpha}_k\) follows the generic shape of the true attude. The drift is least significant in the \(\phi\) direction but was predicting oscillations in the third part of the calibration even though there were no oscillations in the \(\omega_3\) direction at that time, and the drift also changes direction randomly. Drift was most pronounced in the \(\theta\) direction therefore the estimate becomes less accurate over time.

\sphinxAtStartPar
Drift is caused by the error associated with the numerical integration accumulating over time. The unexpected oscillations are likely from the gyroscope being sensetive to noise. Furthermore the oscillations could be coupled meaning small oscillations in one direction can be amplified in another.


\section{5.2 Kalman filters}
\label{\detokenize{5IMU:kalman-filters}}
\sphinxAtStartPar
The model can be improved using a Kalman filter. However there is a problem as its not possible to put our update equation \eqref{equation:5IMU:euler-method2} into the form required for the kalman filter \eqref{equation:2KalmanFilters:projection}. To fix this the attitude was instead written in quaternions.

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Use Euler parameters:
\begin{align}\label{equation:5IMU:eq-EPs}\!\begin{aligned}
\beta_0 = \sin\frac{\phi}{2}\sin\frac{\theta}{2}\sin\frac{\psi}{2} + \cos\frac{\phi}{2}\cos\frac{\theta}{2}\cos\frac{\psi}{2}\\
\beta_1 = \sin\frac{\phi}{2}\cos\frac{\theta}{2}\cos\frac{\psi}{2} + \cos\frac{\phi}{2}\sin\frac{\theta}{2}\sin\frac{\psi}{2}\\
\beta_2 = \cos\frac{\phi}{2}\sin\frac{\theta}{2}\cos\frac{\psi}{2} + \sin\frac{\phi}{2}\cos\frac{\theta}{2}\sin\frac{\psi}{2}\\
\beta_3 = \cos\frac{\phi}{2}\cos\frac{\theta}{2}\sin\frac{\psi}{2} + \sin\frac{\phi}{2}\sin\frac{\theta}{2}\cos\frac{\psi}{2}\\
\end{aligned}\end{align}\end{sphinxadmonition}

\sphinxAtStartPar
Below is the corresponding Euler parameters KDE:
\begin{equation}\label{equation:5IMU:EP-KDE}
\begin{split}\begin{bmatrix} \dot{\beta_0} \\ \dot{\beta_1} \\ \dot{\beta_2} \\ \dot{\beta_3} \end{bmatrix} = \frac{1}{2} \begin{bmatrix} 0 & -\omega_1 & -\omega_2 & -\omega_3 \\ \omega_1 & 0 & \omega_3 & -\omega_2 \\ \omega_2 & -\omega_3 & 0 & \omega_1 \\ \omega_3 & \omega_2 & -\omega_1 & 0\end{bmatrix} \begin{bmatrix} \beta_0 \\ \beta_1 \\ \beta_2 \\ \beta_3 \end{bmatrix}\end{split}
\end{equation}
\sphinxAtStartPar
{[}\hyperlink{cite.99Bibliography:id3}{BAOOl21}{]} (chapter 11.3) or more simply:

\begin{sphinxShadowBox}
\sphinxstylesidebartitle{}

\sphinxAtStartPar
Where: \(\Psi(\omega) = \frac{1}{2} \begin{bmatrix} 0 & -\omega_1 & -\omega_2 & -\omega_3 \\ \omega_1 & 0 & \omega_3 & -\omega_2 \\ \omega_2 & -\omega_3 & 0 & \omega_1 \\ \omega_3 & \omega_2 & -\omega_1 & 0\end{bmatrix}\)
\end{sphinxShadowBox}
\begin{equation}\label{equation:5IMU:eq-KDE-simp}
\begin{split}\boldsymbol{\dot{\beta}} = \Psi(\boldsymbol{\omega}) \boldsymbol{\beta}\end{split}
\end{equation}
\sphinxAtStartPar
\(\boldsymbol{\dot{\beta}}\) was integrated using the same method as \eqref{equation:5IMU:eq-euler}.
\begin{equation}\label{equation:5IMU:eq-Euler3}
\begin{split}\boldsymbol{\beta_{k+1}} \approx \boldsymbol{\beta}_k + \dot{\boldsymbol{\beta}}_k\Delta t\end{split}
\end{equation}
\sphinxAtStartPar
\(\approx\) was used instead of \(=\) for the same reason as in the previous example the numerical integration will mean \(\beta_{k}\) drifts further away from its true value as \(k\) increases. Now sub in \eqref{equation:5IMU:eq-KDE-simp}:
\begin{equation}\label{equation:5IMU:eq-Euler4}
\begin{split}\boldsymbol{\beta}_{k+1} \approx (\mathbb{I} + \Delta t \Psi(\boldsymbol{\omega}))\boldsymbol{\beta}_k\end{split}
\end{equation}
\sphinxAtStartPar
Rewriting \eqref{equation:5IMU:eq-Euler4} with \(\beta_{k-1}\) on the right hand side side being the previous estimate estimate of the state and \(\beta\) on the left hand side becoming the prediction of the state:
\begin{equation}\label{equation:5IMU:eq-proj-att}
\begin{split}\hat{\boldsymbol{x}}^-_{k+1} = (I + \Delta t \Psi(\boldsymbol{\omega}))\hat{\boldsymbol{x}}_k\end{split}
\end{equation}
\sphinxAtStartPar
Which is in the form required by \eqref{equation:2KalmanFilters:projection} with \(A = (I + \Delta t \Psi(\omega))\)
It follows from the euler parameters \eqref{equation:5IMU:eq-EPs} and \(\boldsymbol{\alpha}_0 = \boldsymbol{0}\) that \(\hat{x}_0 = \begin{bmatrix} 1 \\ 0 \\ 0 \\ 0 \end{bmatrix}\).

\sphinxAtStartPar
The gyroscope data was used in the prediction step of the kalman filter, since it relies on the previous state to be able to predict the next state. The correction measurement used in this example will be the previous state \(\hat{x}_k\), this will help reduce noise in the estimate.

\begin{sphinxadmonition}{important}{Important:}
\sphinxAtStartPar
A correction measurement measures the state without needing to rely on previous measurements or approximations its error should be random. A prediction relies on previous measurements. In this case the prediction measurement error is systematic because of integration drift.
\end{sphinxadmonition}

\sphinxAtStartPar
Since both \(z_k\) and \(\hat{x}_k\) represent euler parameters \(H = \mathbb{I}_{4 \times 4}\) which can be understood from \eqref{equation:2KalmanFilters:eq-h-calculate}. Finally the tuning parameters were set \(Q = q\mathbb{I}_{4 \times 4}\), \(R = r\mathbb{I}_{4 \times 4}\) and \(P_0 = p\mathbb{I}_{4 \times 4}\) to allow for simple tuning.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
It is unlikely that optimal \(Q\), \(R\) and \(P^-_0\) are scalar multiples of the identity, but this method reduces the number of parameters that need to be tuned.
\end{sphinxadmonition}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{AttitudeKalman}.jpg}
\caption{Kalman filter block diagram specific to attitude determination.}\label{\detokenize{5IMU:id2}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Compare2}.png}
\caption{The euler method for calculating attitude alongside the kalman filtered example discussed above. \sphinxhref{https://github.com/MalachiHibbins/IMU/tree/main/5IMU}{View in Github}}\label{\detokenize{5IMU:id3}}\end{figure}

\sphinxAtStartPar
This kalman filter example hasn’t improved the fit. The integration drift hasn’t been corrected for. This is because the measurement in this case didn’t contain any corrective information so didn’t correct for drift. \sphinxstylestrong{The only difference the kalman filter makes in this case is it puts a greater emphasis on previous measurements}. A better choice would be to use a sensor which doesn’t rely on the previous measurement to calculate attitude.


\section{5.3 Kalman filters with sensor fusion}
\label{\detokenize{5IMU:kalman-filters-with-sensor-fusion}}
\sphinxAtStartPar
Sensor fusion involves combining different sensors to get a better estimate. A typical six axis IMU will contain a gyroscope and an accelerometer. Accelerometer data to calculate attitude but is noisier than gyroscope data. However accelerometer data can be used to calculate attitude without drift as it doesn’t involve numerical integration. The aim of this part is to use the kalman filter to do sensor fusion to produce a filtered signal with less noise than the accelerometer and no drift.


\subsection{Accelerometer Data}
\label{\detokenize{5IMU:accelerometer-data}}
\sphinxAtStartPar
Here accelerometer data is used to calculate \(\boldsymbol{z}_k\) which represents the attitude in terms of euler parameters as measured using the accelerometer. The accelerometer measures the acceleration, \(\boldsymbol{a}\) in the x, y and z directions. A accelerometer moving at a constant velocity can always identify which direction is down due to the acceleration from gravity. This means it can determine \(\theta\) and \(\phi\) but not \(\psi\).

\sphinxAtStartPar
The acceleration in the body fixed frame, the frame of the craft as seen by a stationary observer on earth is given by:

\begin{sphinxShadowBox}
\sphinxstylesidebartitle{}

\sphinxAtStartPar
Where \(\boldsymbol{g} = \begin{bmatrix} 0 \\ 0 \\ g \end{bmatrix}\)
\end{sphinxShadowBox}
\begin{equation}\label{equation:5IMU:accelerometer2}
\begin{split}[\boldsymbol{a}]_B = [\dot{\boldsymbol{v}}]_B - [\boldsymbol{g}]_B\end{split}
\end{equation}
\sphinxAtStartPar
Where \(\dot{\boldsymbol{v}}\) is the translational acceleration and \(\boldsymbol{g}\) is the acceleration due to gravity. \sphinxstylestrong{Assumption: the translational acceleration of the body is zero and the accelerometer is located at the center of rotation for this example.}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
B is the linear transformation matrix which transforms form the frame of the earth to the frame of the device.
\begin{equation*}
\begin{split}B = \begin{bmatrix}
\cos \psi \cos \theta & \sin \psi \cos \theta & -\sin \theta \\
\cos \psi \sin \theta \sin \phi - \cos \phi \sin \psi & \sin \psi \sin \theta \sin \phi + \cos \phi \cos \psi & \cos \theta \sin \phi \\
\cos \psi \sin \theta \cos \phi + \sin \phi \sin \psi & \sin \psi \sin \theta \cos \phi - \sin \phi \cos \psi & \cos \theta \cos \phi
\end{bmatrix} \end{split}
\end{equation*}
\sphinxAtStartPar
This can be written in terms of unit vectors describing the effects on the \(x\), \(y\) and \(z\) components.
\begin{equation*}
\begin{split}B = \begin{bmatrix} \hat{\boldsymbol{n}}_x & \hat{\boldsymbol{n}}_y & \hat{\boldsymbol{n}}_z \end{bmatrix}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\hat{n}_x\), \(\hat{n}_y\) and \(\hat{n}_z\) are 3 dimensional unit vectors in the \(x\), \(y\) and \(z\) directions.
\end{sphinxadmonition}

\sphinxAtStartPar
The acceleration in the frame of the body can be calculated from its position relative to the earth:
\begin{equation}\label{equation:5IMU:eq-accelerometer2}
\begin{split}[\boldsymbol{a}]_B = - B\boldsymbol{g}  = - g \hat{\boldsymbol{n}}_z = g \begin{bmatrix} \sin{\theta} \\ -\cos{\theta}\sin{\phi} \\ -\cos{\theta}\cos{\phi} \end{bmatrix}\end{split}
\end{equation}
\sphinxAtStartPar
In component form \(\boldsymbol{a} = \begin{bmatrix} a_1 \\ a_2 \\ a_3 \end{bmatrix}\) rearranging \eqref{equation:5IMU:eq-accelerometer2} gets:
\begin{equation}\label{equation:5IMU:accelerometer3}
\begin{split}\theta = \arcsin(\frac{a_1}{g}) \quad \phi = \arcsin(\frac{-a_2}{g\cos{\theta}})\end{split}
\end{equation}
\sphinxAtStartPar
From the accelerometer data alone it is possible to directly calculate \(\theta\) and \(\phi\) but not \(\psi\). In this example let \(\psi = 0\) since no oscillations were performed in the \(\omega_3\) direction.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Additional noise has been added to the accelerometer readings to make the effects of the kalman filter more visible. Usually the accelerometer is more sensitive to noise than the gyroscope. Although the accelerometer data in the next few examples is definitely nosier it is hard to visualize, therefore additional gaussian noise has been added.
\end{sphinxadmonition}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Acc}.png}
\caption{yaw\sphinxhyphen{}pitch\sphinxhyphen{}roll against time using only accelerometer data for the same calibration mentioned above. \sphinxhref{https://github.com/MalachiHibbins/IMU/tree/main/5IMU}{View in Github}}\label{\detokenize{5IMU:acc}}\end{figure}

\sphinxAtStartPar
\hyperref[\detokenize{5IMU:acc}]{Fig.\@ \ref{\detokenize{5IMU:acc}}} is much nosier than the predicted data from the gyroscope, see \hyperref[\detokenize{5IMU:roll-pitch-yaw-drift-real}]{Fig.\@ \ref{\detokenize{5IMU:roll-pitch-yaw-drift-real}}}. For small \(k\) the gyroscope is more accurate as the drift is less significant compared to the noise from the accelerometer however for large \(k\) the accelerometer is more accurate as the gyroscope measurements are subject to drift.


\subsection{Improved Kalman Filter}
\label{\detokenize{5IMU:improved-kalman-filter}}
\sphinxAtStartPar
Using the real world accelerometer and gyroscope data \(Q\) and \(R\) were tuned to obtain the optimal fit for the data.

\begin{sphinxShadowBox}
\sphinxstylesidebartitle{}

\sphinxAtStartPar
Given quaternion components \(\boldsymbol{\beta}_0\) ( \(\beta_1\), \(\beta_2\), and \(\beta_3\)) the Euler angles ( \(\phi\), \(\theta\), \(\psi\)) can be calculated as:
\begin{equation*}
\begin{split}\phi &= \arctan\left(\frac{2(\beta_1 \beta_2 + \beta_0 \beta_3)}{\beta_0^2 + \beta_1^2 - \beta_2^2 - \beta_3^2}\right) \\
\theta &= \arcsin\left(-2(\beta_1 \beta_3 - \beta_0 \beta_2)\right) \\
\psi &= \arctan\left(\frac{2(\beta_2 \beta_3 + \beta_0 \beta_1)}{\beta_0^2 - \beta_1^2 - \beta_2^2 + \beta_3^2}\right)\end{split}
\end{equation*}\end{sphinxShadowBox}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Kalman_Filter_Tuning_test}.png}
\caption{Testing the kalman filter with small \(q\) and large \(r\). \(\phi_a\) represents \(\phi\) measured from accelerometer data. \(\phi_f\) represents \(\phi\) from the kalman filter with sensor fusion. \sphinxhref{https://github.com/MalachiHibbins/IMU/tree/main/5IMU}{View in Github}}\label{\detokenize{5IMU:test1}}\end{figure}

\sphinxAtStartPar
\hyperref[\detokenize{5IMU:test1}]{Fig.\@ \ref{\detokenize{5IMU:test1}}} is similar to the predicted data in \hyperref[\detokenize{5IMU:roll-pitch-yaw-drift-real}]{Fig.\@ \ref{\detokenize{5IMU:roll-pitch-yaw-drift-real}}} which would suggest the filter is working correctly as small \(q\) and large \(r\) mean the filter gives more weighting to predicted (gyroscope) data compared to measured (accelerometer) data.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Kalman_Filter_Tuning_test2}.png}
\caption{Testing the kalman filter with large \(q\) and small \(r\). \(\phi_a\) represents \(\phi\) measured from accelerometer data. \(\phi_f\) represents \(\phi\) from the kalman filter with sensor fusion. \sphinxhref{https://github.com/MalachiHibbins/IMU/tree/main/5IMU}{View in Github}}\label{\detokenize{5IMU:test2}}\end{figure}

\sphinxAtStartPar
\hyperref[\detokenize{5IMU:test2}]{Fig.\@ \ref{\detokenize{5IMU:test2}}} is very noisy and is similar to the predicted data in \hyperref[\detokenize{5IMU:acc}]{Fig.\@ \ref{\detokenize{5IMU:acc}}}, similarly this would suggest the filter is working correctly since large \(q\) and small \(r\) mean the filter gives more weighting to measured data compared to predicted data.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Kalman_Filter_Tuning1}.png}
\caption{Kalman filter tuned optimally by eye. \(\phi_a\) represents \(\phi\) measured from accelerometer data. \(\phi_f\) represents \(\phi\) from the kalman filter with sensor fusion. \sphinxhref{https://github.com/MalachiHibbins/IMU/tree/main/5IMU}{View in Github}}\label{\detokenize{5IMU:tuning}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Kalman_Filter_Tuning_zoomed}.png}
\caption{Zoomed in \hyperref[\detokenize{5IMU:tuning}]{Fig.\@ \ref{\detokenize{5IMU:tuning}}}. \(\phi_a\) represents \(\phi\) measured from accelerometer data. \(\phi_f\) represents \(\phi\) from the kalman filter with sensor fusion. \sphinxhref{https://github.com/MalachiHibbins/IMU/tree/main/5IMU}{View in Github}}\label{\detokenize{5IMU:tuningzoomed}}\end{figure}

\sphinxAtStartPar
\hyperref[\detokenize{5IMU:tuning}]{Fig.\@ \ref{\detokenize{5IMU:tuning}}} and \hyperref[\detokenize{5IMU:tuningzoomed}]{Fig.\@ \ref{\detokenize{5IMU:tuningzoomed}}} show the kalman filter has produced a very good fit. The filtered signal appears both noise, drift and delay free.


\section{5.4 Summary}
\label{\detokenize{5IMU:summary}}
\sphinxAtStartPar
Lets compare all three filters side by side.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Comparison3}.png}
\caption{All three filters side by side. \sphinxhref{https://github.com/MalachiHibbins/IMU/tree/main/5IMU}{View in Github}}\label{\detokenize{5IMU:fig-comparison3}}\end{figure}

\sphinxAtStartPar
Figure \hyperref[\detokenize{5IMU:fig-comparison3}]{Fig.\@ \ref{\detokenize{5IMU:fig-comparison3}}} shows the only the kalman filter (with fusion) is accurate for determining attitude in the longrun. Even though the error from numerical integration is small if it isn’t regularly corrected for will be subject to integration drift.

\sphinxAtStartPar
The Kalman filter produced an excellent fit in this case as the prediction (from gyroscope) and measurement (from accelerometer) were complimentary to each other. The gyroscope was less susceptible to noise but was susceptible to drift whereas the accelerometer was more susceptible to noise and less susceptible to drift. Sensor fusion gets the best of both worlds.

\begin{sphinxadmonition}{note}{Idea}

\sphinxAtStartPar
Rewrite the part of the code that carries out kalman filter calculations and determines A in C++ as the programme runs really slowly.
\end{sphinxadmonition}

\sphinxstepscope


\chapter{6 Example : Position using GPS and accelerometer data}
\label{\detokenize{6ExtendedKalman:example-position-using-gps-and-accelerometer-data}}\label{\detokenize{6ExtendedKalman::doc}}
\sphinxAtStartPar
This section improves on the {\hyperref[\detokenize{6ExtendedKalman:4bExampleVelocityFromPosition.md}]{\sphinxcrossref{\DUrole{xref,myst}{the velocity from position example}}}} example by using sensor fusion. While the system using only position data (theoretically measured using GPS) works well for predicting the position, its not so good at predicting the velocity. The current model \eqref{equation:4ExampleVelocityFromPosition:eq-motion-equations} represents an oversimplification as it assumes no acceleration (the acceleration doesn’t change between steps) which means that the velocity has to be corrected for by the measurements which is what causes lag. The model could be improved using real world accelerometer data which can be integrated to find velocity and position. There are other reasons for including the accelerometer data for example when GPS isn’t available due to some form of blocking e.g. being in a tunnel, the device can still roughly determine its position.


\section{6.1 Model}
\label{\detokenize{6ExtendedKalman:model}}
\sphinxAtStartPar
Starting with the 1D case the new model is built on \eqref{equation:4ExampleVelocityFromPosition:eq-motion-equations} with an additional 2nd order term:
\begin{equation}\label{equation:6ExtendedKalman:eq-motion-equations2}
\begin{split}s_{k+1} &\approx s_k + \nu_k\Delta t + \frac{1}{2}a_k \Delta t^2\\
\nu_{k+1} &\approx \nu_k + a_k\Delta t\end{split}
\end{equation}
\sphinxAtStartPar
The parameters from {\hyperref[\detokenize{6ExtendedKalman:4bExampleVelocityFromPosition.md:model}]{\sphinxcrossref{\DUrole{xref,myst}{the velocity from position model}}}} remain the same, except for the model \(A\):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(\hat{\boldsymbol{x}}\) is the column vector of position and velocity

\item {} 
\sphinxAtStartPar
\(z\) is the measurment of position from the GPS

\item {} 
\sphinxAtStartPar
\(H = \begin{bmatrix} 1 & 0 \end{bmatrix}\)

\item {} 
\sphinxAtStartPar
\(Q = \sigma_a^2 \begin{bmatrix} \frac{\Delta t^4}{4} & \frac{\Delta t^3}{2} \\ \frac{\Delta t^3}{2} & \Delta t^2 \end{bmatrix}\) Where \(\sigma_a\) will be the standard deviation in the acceleration measurements.

\item {} 
\sphinxAtStartPar
\(R = \sigma_s^2\) Where \(\sigma_s\) will be the standard deviation in the position measurements.
\(A\) needs to be a \(2 \times 2\) matrix, since it has the same number of rows and columns as the number of entries in \(\hat{z}\), but this isn’t possible since \eqref{equation:6ExtendedKalman:eq-motion-equations2} contains 3 terms.

\end{itemize}

\begin{sphinxShadowBox}
\sphinxstylesidebartitle{}

\sphinxAtStartPar
If \(\mu_x\) is transformed linearly \(\mu_y = F\mu_x\) its covariance matrix, \(\Sigma_x\), can be transformed using \(\Sigma_y = F\Sigma_xF^T\). {[}\hyperlink{cite.99Bibliography:id3}{BAOOl21}{]} (chapter 2)
\end{sphinxShadowBox}

\begin{sphinxadmonition}{note}{Extended Kalman Filters}

\sphinxAtStartPar
Its not possible to write the prediction stage of the kalman filter as a linear transformation. The extended kalman filter predicts the next state using:
\begin{equation}\label{equation:6ExtendedKalman:eq-proj-ext}
\begin{split}\hat{\boldsymbol{x}}^-_{k+1} = A\hat{\boldsymbol{x}}_k + B\boldsymbol{u}_k\end{split}
\end{equation}
\sphinxAtStartPar
Where \(u_k\) is the forcing function and \(B\) is its associated control matrix where \(u_k\) is the forcing function and \(B\) is its associated control matrix.
\begin{equation}\label{equation:6ExtendedKalman:eq-proj-cov-ext}
\begin{split}P^-_{k+1} = A_kP_kA_k^T+B_kR^uB_k^T+Q\end{split}
\end{equation}
\sphinxAtStartPar
Where \(R^u\) is the associated error covariance matrix for \(u_k\). Equation \eqref{equation:6ExtendedKalman:eq-proj-cov-ext} is the updated form of \eqref{equation:2KalmanFilters:eq-error-covariance-update} with the final term \(B_kR^uB_k^T\) corresponding to the covariance update for \(R^u\). \(R^u\) becomes one of our kalman parameters when using the extended kalman filter.

\begin{figure}[H]
\centering
\capstart

\noindent\sphinxincludegraphics{{ExpandedKalman}.jpg}
\caption{Block diagram for the extended kalman filter. The estimation phase is equivalent to \hyperref[\detokenize{2KalmanFilters:fig-kalman-block-diagram}]{Fig.\@ \ref{\detokenize{2KalmanFilters:fig-kalman-block-diagram}}} but the prediction stage has been updated.}\label{\detokenize{6ExtendedKalman:fig-block-kalman}}\end{figure}
\end{sphinxadmonition}

\sphinxAtStartPar
So \eqref{equation:6ExtendedKalman:eq-motion-equations2} was rewritten in the form of \eqref{equation:6ExtendedKalman:eq-proj-cov-ext} to determine \(u_k\) and \(B\).
\begin{equation*}
\begin{split}\begin{bmatrix} s \\ \nu \end{bmatrix}^-_{k+1} = \begin{bmatrix} 1 & \Delta t \\ 0 & 1 \end{bmatrix} \begin{bmatrix} s \\ \nu \end{bmatrix}_k + \begin{bmatrix} \frac{1}{2} \Delta t^2 \\ \Delta t \end{bmatrix} a_k.\end{split}
\end{equation*}
\sphinxAtStartPar
Which gives \(u_k = \begin{bmatrix} \frac{1}{2} \Delta t^2 \\ \Delta t \end{bmatrix}\) and \(u_k = a_k\). The tuning parameter will be \(R^u = \sigma_a'^2\) determine by tuning.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-31}.png}
\caption{Velocity and position as a function of time plotted for the extended kalman filter using the same parameters in \hyperref[\detokenize{4ExampleVelocityFromPosition:fig-increased-r-and-increased-q}]{Fig.\@ \ref{\detokenize{4ExampleVelocityFromPosition:fig-increased-r-and-increased-q}}}, tuned by eye. \sphinxhref{https://github.com/MalachiHibbins/IMU/tree/main/6ExtendedKalman}{View in Github}}\label{\detokenize{6ExtendedKalman:fig-improved-vel-pos}}\end{figure}

\sphinxAtStartPar
Compared to \hyperref[\detokenize{4ExampleVelocityFromPosition:fig-increased-r-and-increased-q}]{Fig.\@ \ref{\detokenize{4ExampleVelocityFromPosition:fig-increased-r-and-increased-q}}} the extended kalman filter with acceleration measurements gives a better fit for position and a significantly better fit for velocity, helped by the significantly better model. Even without measurement corrections the accelerometer gives a surprisingly good fit although there is a tiny bit of drift visible at the end. However the drift is significantly larger when integrated twice.


\section{6.2 Smartphone experiment}
\label{\detokenize{6ExtendedKalman:smartphone-experiment}}
\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Incomplete section. It is left here as a placeholder for future work. The experiment would have involved using kalman filters to determine the real world position and velocity of a smartphone using accelerometer and GPS data. This would have needed to consider the GPS and accelerometer having different sampling rates and noise characteristics.
\end{sphinxadmonition}

\sphinxstepscope


\chapter{7 Experiment: Attitude Using a 6/9 axis IMU}
\label{\detokenize{7RealData:experiment-attitude-using-a-6-9-axis-imu}}\label{\detokenize{7RealData::doc}}
\sphinxAtStartPar
This section explores examples similar to {\hyperref[\detokenize{5IMU::doc}]{\sphinxcrossref{\DUrole{std,std-doc}{section 5}}}} but using real data. Initially using a gyroscope and an accelerometer, a 6 axis IMU, and later using a magnetometer as well, a 9 axis IMU. The 6 axis example uses the MPU6050 with an arduino controller and the 9 axis example used the mobile phone sensors with the \sphinxhref{https://play.google.com/store/apps/details?id=com.kelvin.sensorapp\&amp;hl=en-US\&amp;pli=1}{sensor logger} app.


\section{Implementation}
\label{\detokenize{7RealData:implementation}}
\sphinxAtStartPar
The code for this section can be found \sphinxhref{https://github.com/MalachiHibbins/IMU/tree/main/7IMUReal}{here}. The main file is \sphinxcode{\sphinxupquote{Analysis.py}} which contains \sphinxcode{\sphinxupquote{AnalyseMPU}} class which is the parent class for \sphinxcode{\sphinxupquote{AnalysePhone}} and \sphinxcode{\sphinxupquote{AnalyseTest}}, these read data from the MPU6050, sensor logger and test data (from {\hyperref[\detokenize{5IMU::doc}]{\sphinxcrossref{\DUrole{std,std-doc}{section 5}}}}) respectively.


\subsection{Raw Data from MPU6050}
\label{\detokenize{7RealData:raw-data-from-mpu6050}}
\sphinxAtStartPar
Each file with measurements came with its own calibration file, which was used to determine the offset in each direction. Different tests were performed with the MPU6050, the data for these are contained in the folders:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{YawPitchRoll}}: Involves fast oscillations in the yaw direction followed by a short break, then oscillations in the roll direction followed by a short break, then oscillations in the pitch direction.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FullYaw}}: Contains data where the MPU6050 was rotated in a full circle in the yaw direction and then rotated back in the opposite direction.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FullPitch}}: Contains data where the MPU6050 was rotated in a full circle in the pitch direction and then rotated back in the opposite direction.

\end{itemize}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Currently the Kalman filter will only correctly fit \sphinxcode{\sphinxupquote{YawPitchRoll}} data. When the sensor was rotated beyond \(180^o\) in the yaw and roll directions or beyond \(90^o\) in the pitch direction the Kalman filter will need to re\sphinxhyphen{}normalize the attitude, which made it difficult to fit the Kalman filter. This wasn’t a problem with \sphinxcode{\sphinxupquote{YawPitchRoll}} data as no full rotations were performed.
\end{sphinxadmonition}


\subsection{Raw Data From Sensor Logger}
\label{\detokenize{7RealData:raw-data-from-sensor-logger}}
\sphinxAtStartPar
The data collected can be found \sphinxhref{https://github.com/MalachiHibbins/IMU/tree/main/7IMUReal/SensorLoggerData}{here}. Each folder contains a different test and contains the following files:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{In all cases time was measured in seconds.}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Gravity.csv}}: Contains the acceleration readings without the acceleration due to gravity removed. \sphinxstyleemphasis{The x, y and z components are measured in ms\(^{-2}\)}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Magnetometer.csv}}: Contains the magnetometer readings in the phone’s frame of reference. \sphinxstyleemphasis{The x, y and z components are measured in \(\mu\)T.}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Gyroscope.csv}}: Contains the gyroscope readings in the phone’s frame of reference. \sphinxstyleemphasis{x, y and z are measured in radians rads\(^{-1}\)}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Orientation.csv}}: Contains the orientation of the phone in yaw\sphinxhyphen{}pitch\sphinxhyphen{}roll measured in radians. We will refer to this as the true orientation as its the orientation calculated by the phone.
All other files are not used in this analysis.

\end{itemize}

\sphinxAtStartPar
Tests were performed and stored in the folders:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PitchRollCalibration}}: Fast movement in the pitch direction followed by a short break, then motion in a combination of the pitch and roll directions followed by a short break, then motion in just the roll direction, this was the same test as in {\hyperref[\detokenize{5IMU::doc}]{\sphinxcrossref{\DUrole{std,std-doc}{section 5}}}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{YawRollPitchCalibration}}: Contains data for a calibration test where the phone was moved in each direction alone followed by a short pause.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FullYaw}}: Contains data where the phone was rotated in a full circle in the yaw direction and then rotated back in the opposite direction.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FullPitch}}: Contains data where the phone was rotated in a full circle in the pitch direction and then rotated back in the opposite direction.

\end{itemize}


\subsection{Programme structure}
\label{\detokenize{7RealData:programme-structure}}
\sphinxAtStartPar
The programme is structured with three files:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{AdvKalman.py}}: Contains the Kalman filter implementation and handles the conversion between quaternions and Euler angles.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{OrientationKalman.py}}: Contains the \sphinxcode{\sphinxupquote{run}} function which runs the Kalman filter on the data and returns the filtered signal, Euler angles from the accelerometer and gyroscope, and the magnetometer readings. It acts as an interface between \sphinxhref{http://Analysis.py}{Analysis.py} and \sphinxhref{http://AdvKalman.py}{AdvKalman.py}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Analysis.py}}: Contains the \sphinxcode{\sphinxupquote{AnalysePhone}} class which is used to read in the data, run the Kalman filter and plot the results.

\end{itemize}


\section{Theory, 9 axis}
\label{\detokenize{7RealData:theory-9-axis}}
\sphinxAtStartPar
In {\hyperref[\detokenize{5IMU::doc}]{\sphinxcrossref{\DUrole{std,std-doc}{section 5}}}} gyroscope data and accelerometer data were fused to determine the attitude of the phone. However the accelerometer on its own was unable to measure the yaw direction. When phone is lying flat in the xy plane \(z^\psi\), can be determined easily:
\begin{equation}\label{equation:7RealData:eq-Magnetometer}
\begin{split}z^\psi = \arctan\left(\frac{m_y}{m_x}\right)\end{split}
\end{equation}
\sphinxAtStartPar
Where \(m_x\) and \(m_y\) are the x and y components of the magnetometer reading. The magnetometer reading is in the phone’s frame of reference this is normally not the xy plane so the accelerometer data to is required to write the corrected magnetometer readings \(m_x'\) and \(m_y'\).
\begin{equation}\label{equation:7RealData:eq-gyro-correction}
\begin{split}m_x^{'} = m_x \cos(z^\theta) + m_y \sin(z^\theta) \sin(z^\phi) + m_z \sin(z^\theta) \cos(z^\phi)\\
m_y^{'} = m_y \cos(z^\theta) - m_x \sin(z^\theta) \sin(z^\phi) + m_z \sin(z^\theta) \cos(z^\phi)\\\end{split}
\end{equation}
\sphinxAtStartPar
Where \(z^\phi\) and \(z^\theta\) are the roll and pitch angles calculated using the accelerometer.

\sphinxAtStartPar
Then as before \(z^\psi\) and \(z^\phi\) were calculated using the accelerometer and were used to correct \(z^\psi\) when the magnetometer isn’t lying flat in the xy plane. To summarize the update measurement will be formed from the accelerometer, for pitch and roll and the magnetometer for yaw. The prediction step will use measurements from the gyroscope in the same way as {\hyperref[\detokenize{5IMU::doc}]{\sphinxcrossref{\DUrole{std,std-doc}{section 5}}}}.


\section{Results}
\label{\detokenize{7RealData:results}}

\subsection{Fast Yaw Pitch Roll}
\label{\detokenize{7RealData:fast-yaw-pitch-roll}}
\sphinxAtStartPar
These examples involved fast oscillations in the yaw directions followed by a short break, then oscillations in the roll direction followed by a short break, then oscillations in the pitch direction.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Here yaw\sphinxhyphen{}pitch\sphinxhyphen{}roll is normalized as follows: yaw is in the range \([-\pi, \pi]\), pitch is in the range \([-\pi/2, \pi/2]\) and roll is in the range \([-\pi, \pi]\).
\end{sphinxadmonition}


\subsubsection{MPU6050 6\sphinxhyphen{}axis IMU}
\label{\detokenize{7RealData:mpu6050-6-axis-imu}}
\sphinxAtStartPar
So that the correction was normalized the correction in the yaw direction was set to always be zero, the pitch and roll directions came from accelerometer measurements. The prediction came from gyroscope measurements.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-39}.png}
\caption{Fast oscillations in the yaw, roll and pitch directions. The orange line is the measurements from integrating the angular velocities from the gyro and red line is the measurements from the accelerometer. The blue line is the Kalman filtered attitude which fuses data from the gyroscope and accelerometer/magnetometer.}\label{\detokenize{7RealData:fig-fast-yaw-roll-pitch-6-axis}}\end{figure}

\sphinxAtStartPar
The drift is clearly visible from the gyro. But the accelerometer measurements seem to be much more accurate. However it is unclear if Kalman filter improves on the accelerometer measurements with the current \(Q\) and \(R\).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-40}.png}
\caption{The same data as \hyperref[\detokenize{7RealData:fig-fast-yaw-roll-pitch-6-axis}]{Fig.\@ \ref{\detokenize{7RealData:fig-fast-yaw-roll-pitch-6-axis}}} but with the Kalman filter tuned, with larger \(R\) and smaller \(Q\), increasing the weighting on the prediction, the gyro data.}\label{\detokenize{7RealData:fig-fast-yaw-roll-pitch-6-axis-tuned}}\end{figure}

\sphinxAtStartPar
Here the Kalman filter has a much better shape for the yaw direction since there is a greater weighting on the prediction meaning oscillations from the gyro are much more pronounced in the Kalman filter. The Kalman filter also still filters out the drift from the gyro data making it a very accurate fit.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-43}.png}
\caption{Zoomed in on the pitch oscillations in \hyperref[\detokenize{7RealData:fig-fast-yaw-roll-pitch-6-axis}]{Fig.\@ \ref{\detokenize{7RealData:fig-fast-yaw-roll-pitch-6-axis}}}.}\label{\detokenize{7RealData:fig-fast-yaw-roll-pitch-6-axis-zoomed}}\end{figure}

\sphinxAtStartPar
There is a problem in the oscillations in all directions are now delayed as the gyroscope is slower to to changes than the accelerometer, hence by putting more faith in the prediction although the fit more accurately resembles the shape of the true data it is slightly delayed.

\sphinxAtStartPar
The Kalman filter is able to filter out some of the noise from the accelerometer data. The accelerometer data is typically noisier than the gyroscope data, so putting more emphasis on the gyroscope will help to filter out noise.


\subsubsection{Phone, 9\sphinxhyphen{}axis IMU}
\label{\detokenize{7RealData:phone-9-axis-imu}}
\sphinxAtStartPar
Introducing magnetometer measurements means there is 2 measurements for each axis, reducing the total drift.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-32}.png}
\caption{Fast oscillations in the yaw, roll and pitch directions. The orange line is the measurements from integrating the angular velocities from the gyro and red line is the measurements from the magnetometer and accelerometer. The blue line is the Kalman filtered attitude which fuses data from the gyroscope and accelerometer/magnetometer.  The black line is the phones own attitude measurements.}\label{\detokenize{7RealData:fig-fast-yaw-roll-pitch}}\end{figure}

\sphinxAtStartPar
There is significant drift in the measurements from the gyro alone the end measurements from the gyro alone has drifted by approximately \(60^o\) from the true value where as the Kalman filter and the magnetometer/accelerometer data are much better fits. Also the amplitude of the measurements oscillations in the roll direction is much smaller than the yaw and pitch directions. This was because its because of the way the phone had to be held.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-34}.png}
\caption{Zoomed in on the yaw oscillations in \hyperref[\detokenize{7RealData:fig-fast-yaw-roll-pitch}]{Fig.\@ \ref{\detokenize{7RealData:fig-fast-yaw-roll-pitch}}}.}\label{\detokenize{7RealData:fig-fast-yaw-roll-pitch-2}}\end{figure}

\sphinxAtStartPar
Here the Kalman filter is able to correct for both the drift from the gyro and noise from the magnetometer making it a very good fit for yaw. The is interference with the gyroscope in the pitch direction but the Kalman filter successfully filters this out.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-35}.png}
\caption{Zoomed in on the pitch oscillations in \hyperref[\detokenize{7RealData:fig-fast-yaw-roll-pitch}]{Fig.\@ \ref{\detokenize{7RealData:fig-fast-yaw-roll-pitch}}}.}\label{\detokenize{7RealData:id1}}\end{figure}

\sphinxAtStartPar
There is interference in the magnetometer/gyroscope measurements but the Kalman filter filters this out successfully but this does cause drift in the Kalman filter measurements. The gyroscope measurements for Pitch are incredibly noisy possibly due to oversensitivity of the gyroscope in the phone, but the Kalman filter remains a good fit. The Roll direction remains fairly stable.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-36}.png}
\caption{Zoomed in on the roll oscillations in \hyperref[\detokenize{7RealData:fig-fast-yaw-roll-pitch}]{Fig.\@ \ref{\detokenize{7RealData:fig-fast-yaw-roll-pitch}}}.}\label{\detokenize{7RealData:id2}}\end{figure}

\sphinxAtStartPar
For the yaw direction both sets of instruments are indicating the correct shape but there is drift especially in the gyro. There is interference in the pitch direction, again the Kalman filter does a good job of filtering this out.


\subsection{Full Rotation, Yaw}
\label{\detokenize{7RealData:full-rotation-yaw}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-37}.png}
\caption{The phone was rotated in a full circle in the yaw direction and then rotated back in the opposite direction. The orange line is the measurements from integrating the angular velocities from the gyro and red line is the measurements from the magnetometer and accelerometer. The blue line is the Kalman filtered attitude which fuses data from the gyroscope and accelerometer/magnetometer.  The black line is the phones own attitude measurements.}\label{\detokenize{7RealData:fig-full-yaw}}\end{figure}

\sphinxAtStartPar
The Kalman filter is able to reduce noise in the magnetometer measurements but the gyroscope seems to provide the best fit here. This could be because the magnetometer is overly sensitive. However it’s plausible that the phone reliable more on its gyroscope for measurements of orientation since magnetometer data isn’t as reliable due to additional magnetic fields meaning it can be poorly calibrated. Whereas a gyroscope with a small amount of drift will always work.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
I didn’t have enough time during the placement to test the Kalman filter for full rotations.
\end{sphinxadmonition}

\sphinxstepscope


\chapter{8 Experiment: Quantitative Comparison of Kalman Filter Performance}
\label{\detokenize{8TestingFilters:experiment-quantitative-comparison-of-kalman-filter-performance}}\label{\detokenize{8TestingFilters::doc}}
\sphinxAtStartPar
Using two sensors (magnetometer and gyroscope), four filters (a high pass, a low pass, a polynomial fitting and the kalman filter) were used to calculate estimates for the yaw angle, \(\psi\), of a mobile phone. The results were compared to the data from the phones in built filter. The experiment involved two tests designed to see how the filters perform over a single frequency then a range of frequencies. In the first part of the experiment the phone oscillated with high frequency which the parameters were tuned, to test how the filters performed at a single frequency. The second part of the experiment the phone completed a full rotation at a low frequency without the parameters being re\sphinxhyphen{}tuned, to see how the filters responded when not tuned to a specific frequency.


\section{8.1 Implementation}
\label{\detokenize{8TestingFilters:implementation}}
\sphinxAtStartPar
Data was recorded using the \sphinxhref{https://play.google.com/store/apps/details?id=com.kelvin.sensorapp\&amp;hl=en-US\&amp;pli=1}{sensor logger app} allowing the phone to function as a 9\sphinxhyphen{}axis IMU. Only \(\psi\) was measured so only gyroscope and magnetometer data were necessary. The correction measurement was calculated using the magnetometer data \(m_x\) and \(m_y\). \(m_z\) wasn’t required as the IMU was assumed to be in the plane perpendicular to the gravity vector, so didn’t need to be corrected. \(\psi\) was determined using \eqref{equation:7RealData:eq-Magnetometer}.

\sphinxAtStartPar
The gyroscope data was integrated using the euler method:
\begin{equation}\label{equation:8TestingFilters:eq-gyroscope-integration}
\begin{split}\psi_k \approx \psi_{k-1} + \omega_k \Delta t\end{split}
\end{equation}
\sphinxAtStartPar
This time \(\omega_k\) is the gyroscope measurement of angular velocity at time \(k\) in the \(z\) direction. This formed the prediction measurement. The form required by the Kalman filter is \(\hat{x}^-_k = A\hat{x}_{k-1} + Bu_k\). So \(A = 1\) and \(B = dt\) and \(u_k = \omega_k\). The state to measurement matrix \(H = 1\) since \(z_k\) and \(\hat{x}_k\) are both the yaw angle.

\sphinxAtStartPar
The code for this section can be found in \sphinxhref{https://github.com/MalachiHibbins/IMU/tree/main/7IMUReal}{github}. The programme comprises of one file \sphinxcode{\sphinxupquote{Main.py}}. Each of the filters is written as a separate function and can be analyzed using the \sphinxcode{\sphinxupquote{AnalysePhone}} class, which contains methods to generate interactive plots.


\section{8.2 Filters}
\label{\detokenize{8TestingFilters:filters}}
\sphinxAtStartPar
The following filters were compared as well as unfiltered data from the gyroscope and the magnetometer:

\sphinxAtStartPar
\sphinxstylestrong{Kalman Filter} (KF): A standard Kalman filter which \sphinxstylestrong{fused} data from the magnetometer with gyroscope data with a constant process noise covariance and measurement noise covariance. The tuning parameters were:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(Q\): Process noise covariance.

\item {} 
\sphinxAtStartPar
\(R^m\): Measurement noise covariance for the magnetometer measurements.

\item {} 
\sphinxAtStartPar
\(R^g\): Measurement noise covariance for the gyroscope measurements.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{{\hyperref[\detokenize{8TestingFilters:EMAHP.md}]{\sphinxcrossref{\DUrole{xref,myst}{Exponential Moving Average Low Pass Filter}}}}} (EMAHPF): Was applied to the \sphinxstylestrong{magnetometer} data where the Where \(\alpha^{HP}\) is the tuning parameter, to reduce noise.

\sphinxAtStartPar
\sphinxstylestrong{Exponential Moving Average High Pass Filter} (EMAHPF): Was applied to \sphinxstylestrong{gyroscope data} to cutout integration drift (low frequency). \(\alpha^{LP}\) was the tuning parameter.

\sphinxAtStartPar
\sphinxstylestrong{Savitzky\sphinxhyphen{}Golay Filter} (SGF): Was applied to the \sphinxstylestrong{magnetometer data} to help mitigate random noise. It has the following parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(W\): The length of the filter window.

\item {} 
\sphinxAtStartPar
\(\mathbb{O}\): The order of the polynomial used to fit the samples.
The SGF works by fitting a polynomial of order \(\mathbb{O}\) to a window of length \(W\). The center of the window is the fitted value.

\end{itemize}


\section{8.3 Results}
\label{\detokenize{8TestingFilters:results}}

\subsection{High frequency oscillation test}
\label{\detokenize{8TestingFilters:high-frequency-oscillation-test}}
\sphinxAtStartPar
The phone was initially held in a fixed position for around 5 seconds then oscillated at a high frequency for around \(20\) s, each of the filters was tuned to optimise the fit.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-44}.png}
\caption{Shows the signal used and gives an overview of the results and compares the phones own filters against the filters described above. Tuning parameters were set below.}\label{\detokenize{8TestingFilters:high-freq-oscillation}}\end{figure}

\sphinxAtStartPar
\hyperref[\detokenize{8TestingFilters:high-freq-oscillation}]{Fig.\@ \ref{\detokenize{8TestingFilters:high-freq-oscillation}}} shows integration drift is visible in the unfiltered gyroscope data. But all other filters seem to be a good fit from a distance.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-45}.png}
\caption{Zoomed in view of the final few oscillations of the high frequency oscillation experiment with a visually optimized fit.}\label{\detokenize{8TestingFilters:high-freq-oscillation-zoomed}}\end{figure}

\sphinxAtStartPar
\hyperref[\detokenize{8TestingFilters:high-freq-oscillation-zoomed}]{Fig.\@ \ref{\detokenize{8TestingFilters:high-freq-oscillation-zoomed}}} shows the there is integration drift from the unfiltered gyroscope data but not with the EMAHPF since the drift is low\sphinxhyphen{}frequency. The magnetometer measurments are lagging behind the true signal which also effects the EMALPF and SGF. Surprisingly the Kalman filter isn’t lagged as it relies heavily on the gyroscope measurements. The Kalman filter assumes a large amount of noise in the magnetometer, \(R_m\), two orders of magnitude larger than \(R_g\). There is also a small amount of linear process noise.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-46}.png}
\caption{Zoomed in view of the flat proportion of the graph, at the beginning.}\label{\detokenize{8TestingFilters:high-freq-oscillation-zoomed-flat}}\end{figure}

\sphinxAtStartPar
\hyperref[\detokenize{8TestingFilters:high-freq-oscillation-zoomed-flat}]{Fig.\@ \ref{\detokenize{8TestingFilters:high-freq-oscillation-zoomed-flat}}} shows the noisiest sensor is the magnetometer. The SGF reduces some of this noise. The EMALPF actually made the fit worse since the noise from the magnetometer was significantly less significant than its lag, which applying a low\sphinxhyphen{}pass filter actually worsened.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
\(R^2\) measures the pattern\sphinxhyphen{}matching ability of the filter and is sensitive to phase shifts.
MSE (mean squared error) measures absolute accuracy and heavily penalizes large errors due to squaring.
\end{sphinxadmonition}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-47}.png}
\caption{Correlation coefficient squared, \(R^2\) for each of the filters against the phones built in filter.}\label{\detokenize{8TestingFilters:fig-correlation-coefficient}}\end{figure}

\sphinxAtStartPar
None of the measurements using the magnetometer perform well. The best of the magnetometer measurements is the SGF, as it removes a small amount of noise and doesn’t cause significant lag. \hyperref[\detokenize{8TestingFilters:fig-correlation-coefficient}]{Fig.\@ \ref{\detokenize{8TestingFilters:fig-correlation-coefficient}}} suggests that the EMALPF fits the shape the best on the gyro data than the fused KF did, likely a result of lagging magnetometer data which wasn’t corrected for.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-48}.png}
\caption{MSE for each of the filters against the phones builtin filter for the first test.}\label{\detokenize{8TestingFilters:fig-mean-squared-error}}\end{figure}

\sphinxAtStartPar
Conversely \hyperref[\detokenize{8TestingFilters:fig-mean-squared-error}]{Fig.\@ \ref{\detokenize{8TestingFilters:fig-mean-squared-error}}} suggests that KF has a more accurate fit. This suggests that EMALPF fits the shape of the data better than KF but KF is on average more accurate.


\subsection{Low frequency rotations test}
\label{\detokenize{8TestingFilters:low-frequency-rotations-test}}
\sphinxAtStartPar
The phone was held still for around \(8\)s and then was rotated a full circle over the space of the next \(15\)s. The tuning parameters for this experiment are those given in \hyperref[\detokenize{8TestingFilters:high-freq-oscillation}]{Fig.\@ \ref{\detokenize{8TestingFilters:high-freq-oscillation}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-49}.png}
\caption{Comparison of the phones own filters against the filters described above. With tuning parameters the same as \hyperref[\detokenize{8TestingFilters:high-freq-oscillation}]{Fig.\@ \ref{\detokenize{8TestingFilters:high-freq-oscillation}}}.}\label{\detokenize{8TestingFilters:fig-low-frequency-rotations}}\end{figure}

\sphinxAtStartPar
\hyperref[\detokenize{8TestingFilters:fig-low-frequency-rotations}]{Fig.\@ \ref{\detokenize{8TestingFilters:fig-low-frequency-rotations}}} shows that all filters are a good fit for the data except the EMAHPF which filters out the low frequencies even if they are not related to noise, in this case the slow rotation.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-50}.png}
\caption{Zooming in on the last couple of seconds of \hyperref[\detokenize{8TestingFilters:fig-low-frequency-rotations}]{Fig.\@ \ref{\detokenize{8TestingFilters:fig-low-frequency-rotations}}}.}\label{\detokenize{8TestingFilters:fig-low-frequency-rotations-zoom}}\end{figure}

\sphinxAtStartPar
\hyperref[\detokenize{8TestingFilters:fig-low-frequency-rotations-zoom}]{Fig.\@ \ref{\detokenize{8TestingFilters:fig-low-frequency-rotations-zoom}}} shows that there has been some drift from all the filters away from the true yaw. But the Kalman filter is closest to the true value. As expected the gyro produces a much smoother fit compared to the magnetometer. Applying a low pass filter to the magnetometer data would make the fit for gyro data better but this would result in some of the higher frequencies being lost which will result in a worse fit for the first test.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-51}.png}
\caption{\(R^2\) for each of the filters against the phones built in filter.}\label{\detokenize{8TestingFilters:r-squared-test2}}\end{figure}

\sphinxAtStartPar
\hyperref[\detokenize{8TestingFilters:r-squared-test2}]{Fig.\@ \ref{\detokenize{8TestingFilters:r-squared-test2}}} shows the Kalman filter produced the best fit as did all the other filters except the EMAHPF which had a very poor fit. The magnetometer data gave a much better fit in these examples compared to the previous test as the oscillations are significantly slower, the lag is less significant. In general the second signal is much easier to fit than the first.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-52}.png}
\caption{MSE for each of the filters against the phones builtin filter for the second test.}\label{\detokenize{8TestingFilters:mse-test-2}}\end{figure}

\sphinxAtStartPar
\hyperref[\detokenize{8TestingFilters:mse-test-2}]{Fig.\@ \ref{\detokenize{8TestingFilters:mse-test-2}}} indicates the same as \hyperref[\detokenize{8TestingFilters:r-squared-test2}]{Fig.\@ \ref{\detokenize{8TestingFilters:r-squared-test2}}}, the Kalman filter still provides a marginally better fit than the other filters. The EMAHPF, which had the best fit in the first test now has by far the worst fit as discussed earlier.


\section{8.4 Conclusion}
\label{\detokenize{8TestingFilters:conclusion}}
\sphinxAtStartPar
Frequency based filters, like the EMAHPF and EMALPF work well for signals which are oscillating at a constant or near constant frequency, especially when there is only one sensor available. However they work less well for a signal made up from a range of different frequencies, like real world motion. Kalman filters work well in this situation as the combination of measurements minimizes noise from both sensors (which are subject to different types of noise) to achieve a reasonably accurate state estimate, without ignoring any specific frequency data. The parameters of the KF are independent of frequency whereas the EMAHPF and EMALPF have frequency dependent tuning parameters.

\sphinxstepscope


\chapter{Bibliography}
\label{\detokenize{99Bibliography:bibliography}}\label{\detokenize{99Bibliography::doc}}

\section{Resources}
\label{\detokenize{99Bibliography:resources}}
\sphinxAtStartPar
The videos from Dr Shane Ross act as a good introduction to Kalman filters and are what the basics of this research is based from. They are linked here: \sphinxhref{https://www.youtube.com/watch?v=HCd-leV8OkU}{video 1}, \sphinxhref{https://www.youtube.com/watch?v=qCZ2UTgLM\_g\&amp;t=1527s}{video 2} and \sphinxhref{https://www.youtube.com/watch?v=DbE4PMgqp3s\&amp;t=2152s}{video 3}.


\section{References}
\label{\detokenize{99Bibliography:references}}
\begin{sphinxthebibliography}{BAOOl21}
\bibitem[BAOOl21]{99Bibliography:id3}
\sphinxAtStartPar
Armando Barreto, Malek Adjouadi, Francisco R. Ortega, and Nonnarit O\sphinxhyphen{}larnnithipong. "intuitive understanding of kalman filtering with matlab". 2021. URL: \sphinxurl{https://public.ebookcentral.proquest.com/choice/publicfullrecord.aspx?p=6236305}, \sphinxhref{https://doi.org/10.1201/9780429200656}{doi:10.1201/9780429200656}.
\bibitem[BH12]{99Bibliography:id2}
\sphinxAtStartPar
Robert Grover Brown and Patrick Y. C. Hwang. Introduction to random signals and applied kalman filtering : with matlab exercises. 2012. URL: \sphinxurl{http://proquest.safaribooksonline.com/9780470609699}.
\end{sphinxthebibliography}







\renewcommand{\indexname}{Index}
\printindex
\end{document}